{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar helper_1 = require(\"../../lib/helper\");\n\nvar logger_1 = require(\"../../lib/logger\");\n\nvar request_wrapper_1 = require(\"../../lib/request-wrapper\");\n\nvar utils_1 = require(\"../utils\");\n/**\n * A class for shared functionality for storing, and requesting tokens.\n * Intended to be used as a parent to be extended for token request management.\n * Child classes should implement `requestToken()` to retrieve the token\n * from intended sources and `saveTokenInfo(tokenResponse)` to parse and save\n * token information from the response.\n */\n\n\nvar TokenManager =\n/** @class */\nfunction () {\n  /**\n   * Create a new [[TokenManager]] instance.\n   * @constructor\n   * @param {object} options Configuration options.\n   * @param {string} options.url for HTTP token requests.\n   * @param {boolean} [options.disableSslVerification] A flag that indicates\n   *   whether verification of the token server's SSL certificate should be\n   *   disabled or not.\n   * @param {object<string, string>} [options.headers] Headers to be sent with every\n   *   outbound HTTP requests to token services.\n   */\n  function TokenManager(options) {\n    // all parameters are optional\n    options = options || {};\n\n    if (options.url) {\n      this.url = helper_1.stripTrailingSlash(options.url);\n    } // request options\n\n\n    this.disableSslVerification = Boolean(options.disableSslVerification);\n    this.headers = options.headers || {}; // any config options for the internal request library, like `proxy`, will be passed here\n\n    this.requestWrapperInstance = new request_wrapper_1.RequestWrapper(options); // Array of requests pending completion of an active token request -- initially empty\n\n    this.pendingRequests = [];\n  }\n  /**\n   * Retrieve a new token using `requestToken()` in the case there is not a\n   *   currently stored token from a previous call, or the previous token\n   *   has expired.\n   */\n\n\n  TokenManager.prototype.getToken = function () {\n    var _this = this;\n\n    if (!this.accessToken || this.isTokenExpired()) {\n      // 1. request a new token\n      return this.pacedRequestToken().then(function () {\n        return _this.accessToken;\n      });\n    } else {\n      // If refresh needed, kick one off\n      if (this.tokenNeedsRefresh()) {\n        this.requestToken().then(function (tokenResponse) {\n          _this.saveTokenInfo(tokenResponse);\n        });\n      } // 2. use valid, managed token\n\n\n      return Promise.resolve(this.accessToken);\n    }\n  };\n  /**\n   * Setter for the disableSslVerification property.\n   *\n   * @param {boolean} value - the new value for the disableSslVerification\n   *   property\n   * @returns {void}\n   */\n\n\n  TokenManager.prototype.setDisableSslVerification = function (value) {\n    // if they try to pass in a non-boolean value,\n    // use the \"truthy-ness\" of the value\n    this.disableSslVerification = Boolean(value);\n  };\n  /**\n   * Set a completely new set of headers.\n   *\n   * @param {OutgoingHttpHeaders} headers - the new set of headers as an object\n   * @returns {void}\n   */\n\n\n  TokenManager.prototype.setHeaders = function (headers) {\n    if (typeof headers !== 'object') {\n      // do nothing, for now\n      return;\n    }\n\n    this.headers = headers;\n  };\n  /**\n   * Paces requests to request_token.\n   *\n   * This method pseudo-serializes requests for an access_token\n   * when the current token is undefined or expired.\n   * The first caller to this method records its `requestTime` and\n   * then issues the token request. Subsequent callers will check the\n   * `requestTime` to see if a request is active (has been issued within\n   * the past 60 seconds), and if so will queue their promise for the\n   * active requestor to resolve when that request completes.\n   */\n\n\n  TokenManager.prototype.pacedRequestToken = function () {\n    var _this = this;\n\n    var currentTime = utils_1.getCurrentTime();\n\n    if (this.requestTime > currentTime - 60) {\n      // token request is active -- queue the promise for this request\n      return new Promise(function (resolve, reject) {\n        _this.pendingRequests.push({\n          resolve: resolve,\n          reject: reject\n        });\n      });\n    } else {\n      this.requestTime = currentTime;\n      return this.requestToken().then(function (tokenResponse) {\n        _this.saveTokenInfo(tokenResponse);\n\n        _this.pendingRequests.forEach(function (_a) {\n          var resolve = _a.resolve;\n          resolve();\n        });\n\n        _this.pendingRequests = [];\n        _this.requestTime = 0;\n      }).catch(function (err) {\n        _this.pendingRequests.forEach(function (_a) {\n          var reject = _a.reject;\n          reject(err);\n        });\n\n        throw err;\n      });\n    }\n  };\n  /**\n   * Request a token using an API endpoint.\n   *\n   * @returns {Promise}\n   */\n\n\n  TokenManager.prototype.requestToken = function () {\n    var errMsg = '`requestToken` MUST be overridden by a subclass of TokenManagerV1.';\n    var err = new Error(errMsg);\n    logger_1.default.error(errMsg);\n    return Promise.reject(err);\n  };\n  /**\n   * Parse and save token information from the response.\n   * Save the requested token into field `accessToken`.\n   * Calculate expiration and refresh time from the received info\n   * and store them in fields `expireTime` and `refreshTime`.\n   *\n   * @param tokenResponse - Response object from a token service request\n   * @protected\n   * @returns {void}\n   */\n\n\n  TokenManager.prototype.saveTokenInfo = function (tokenResponse) {\n    var errMsg = '`saveTokenInfo` MUST be overridden by a subclass of TokenManager.';\n    var err = new Error(errMsg);\n    logger_1.default.error(errMsg);\n  };\n  /**\n   * Check if currently stored token is expired\n   *\n   * @private\n   * @returns {boolean}\n   */\n\n\n  TokenManager.prototype.isTokenExpired = function () {\n    var expireTime = this.expireTime;\n\n    if (!expireTime) {\n      return true;\n    }\n\n    var currentTime = utils_1.getCurrentTime();\n    return expireTime <= currentTime;\n  };\n  /**\n   * Check if currently stored token should be refreshed\n   * i.e. past the window to request a new token\n   *\n   * @private\n   * @returns {boolean}\n   */\n\n\n  TokenManager.prototype.tokenNeedsRefresh = function () {\n    var refreshTime = this.refreshTime;\n    var currentTime = utils_1.getCurrentTime();\n\n    if (refreshTime && refreshTime > currentTime) {\n      return false;\n    } // Update refreshTime to 60 seconds from now to avoid redundant refreshes\n\n\n    this.refreshTime = currentTime + 60;\n    return true;\n  };\n\n  return TokenManager;\n}();\n\nexports.TokenManager = TokenManager;","map":{"version":3,"sources":["/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/ibm-cloud-sdk-core/auth/token-managers/token-manager.js"],"names":["Object","defineProperty","exports","value","helper_1","require","logger_1","request_wrapper_1","utils_1","TokenManager","options","url","stripTrailingSlash","disableSslVerification","Boolean","headers","requestWrapperInstance","RequestWrapper","pendingRequests","prototype","getToken","_this","accessToken","isTokenExpired","pacedRequestToken","then","tokenNeedsRefresh","requestToken","tokenResponse","saveTokenInfo","Promise","resolve","setDisableSslVerification","setHeaders","currentTime","getCurrentTime","requestTime","reject","push","forEach","_a","catch","err","errMsg","Error","default","error","expireTime","refreshTime"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 IBM Corp. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helper_1 = require(\"../../lib/helper\");\nvar logger_1 = require(\"../../lib/logger\");\nvar request_wrapper_1 = require(\"../../lib/request-wrapper\");\nvar utils_1 = require(\"../utils\");\n/**\n * A class for shared functionality for storing, and requesting tokens.\n * Intended to be used as a parent to be extended for token request management.\n * Child classes should implement `requestToken()` to retrieve the token\n * from intended sources and `saveTokenInfo(tokenResponse)` to parse and save\n * token information from the response.\n */\nvar TokenManager = /** @class */ (function () {\n    /**\n     * Create a new [[TokenManager]] instance.\n     * @constructor\n     * @param {object} options Configuration options.\n     * @param {string} options.url for HTTP token requests.\n     * @param {boolean} [options.disableSslVerification] A flag that indicates\n     *   whether verification of the token server's SSL certificate should be\n     *   disabled or not.\n     * @param {object<string, string>} [options.headers] Headers to be sent with every\n     *   outbound HTTP requests to token services.\n     */\n    function TokenManager(options) {\n        // all parameters are optional\n        options = options || {};\n        if (options.url) {\n            this.url = helper_1.stripTrailingSlash(options.url);\n        }\n        // request options\n        this.disableSslVerification = Boolean(options.disableSslVerification);\n        this.headers = options.headers || {};\n        // any config options for the internal request library, like `proxy`, will be passed here\n        this.requestWrapperInstance = new request_wrapper_1.RequestWrapper(options);\n        // Array of requests pending completion of an active token request -- initially empty\n        this.pendingRequests = [];\n    }\n    /**\n     * Retrieve a new token using `requestToken()` in the case there is not a\n     *   currently stored token from a previous call, or the previous token\n     *   has expired.\n     */\n    TokenManager.prototype.getToken = function () {\n        var _this = this;\n        if (!this.accessToken || this.isTokenExpired()) {\n            // 1. request a new token\n            return this.pacedRequestToken().then(function () {\n                return _this.accessToken;\n            });\n        }\n        else {\n            // If refresh needed, kick one off\n            if (this.tokenNeedsRefresh()) {\n                this.requestToken().then(function (tokenResponse) {\n                    _this.saveTokenInfo(tokenResponse);\n                });\n            }\n            // 2. use valid, managed token\n            return Promise.resolve(this.accessToken);\n        }\n    };\n    /**\n     * Setter for the disableSslVerification property.\n     *\n     * @param {boolean} value - the new value for the disableSslVerification\n     *   property\n     * @returns {void}\n     */\n    TokenManager.prototype.setDisableSslVerification = function (value) {\n        // if they try to pass in a non-boolean value,\n        // use the \"truthy-ness\" of the value\n        this.disableSslVerification = Boolean(value);\n    };\n    /**\n     * Set a completely new set of headers.\n     *\n     * @param {OutgoingHttpHeaders} headers - the new set of headers as an object\n     * @returns {void}\n     */\n    TokenManager.prototype.setHeaders = function (headers) {\n        if (typeof headers !== 'object') {\n            // do nothing, for now\n            return;\n        }\n        this.headers = headers;\n    };\n    /**\n     * Paces requests to request_token.\n     *\n     * This method pseudo-serializes requests for an access_token\n     * when the current token is undefined or expired.\n     * The first caller to this method records its `requestTime` and\n     * then issues the token request. Subsequent callers will check the\n     * `requestTime` to see if a request is active (has been issued within\n     * the past 60 seconds), and if so will queue their promise for the\n     * active requestor to resolve when that request completes.\n     */\n    TokenManager.prototype.pacedRequestToken = function () {\n        var _this = this;\n        var currentTime = utils_1.getCurrentTime();\n        if (this.requestTime > (currentTime - 60)) {\n            // token request is active -- queue the promise for this request\n            return new Promise(function (resolve, reject) {\n                _this.pendingRequests.push({ resolve: resolve, reject: reject });\n            });\n        }\n        else {\n            this.requestTime = currentTime;\n            return this.requestToken().then(function (tokenResponse) {\n                _this.saveTokenInfo(tokenResponse);\n                _this.pendingRequests.forEach(function (_a) {\n                    var resolve = _a.resolve;\n                    resolve();\n                });\n                _this.pendingRequests = [];\n                _this.requestTime = 0;\n            }).catch(function (err) {\n                _this.pendingRequests.forEach(function (_a) {\n                    var reject = _a.reject;\n                    reject(err);\n                });\n                throw (err);\n            });\n        }\n    };\n    /**\n     * Request a token using an API endpoint.\n     *\n     * @returns {Promise}\n     */\n    TokenManager.prototype.requestToken = function () {\n        var errMsg = '`requestToken` MUST be overridden by a subclass of TokenManagerV1.';\n        var err = new Error(errMsg);\n        logger_1.default.error(errMsg);\n        return Promise.reject(err);\n    };\n    /**\n     * Parse and save token information from the response.\n     * Save the requested token into field `accessToken`.\n     * Calculate expiration and refresh time from the received info\n     * and store them in fields `expireTime` and `refreshTime`.\n     *\n     * @param tokenResponse - Response object from a token service request\n     * @protected\n     * @returns {void}\n     */\n    TokenManager.prototype.saveTokenInfo = function (tokenResponse) {\n        var errMsg = '`saveTokenInfo` MUST be overridden by a subclass of TokenManager.';\n        var err = new Error(errMsg);\n        logger_1.default.error(errMsg);\n    };\n    /**\n     * Check if currently stored token is expired\n     *\n     * @private\n     * @returns {boolean}\n     */\n    TokenManager.prototype.isTokenExpired = function () {\n        var expireTime = this.expireTime;\n        if (!expireTime) {\n            return true;\n        }\n        var currentTime = utils_1.getCurrentTime();\n        return expireTime <= currentTime;\n    };\n    /**\n     * Check if currently stored token should be refreshed\n     * i.e. past the window to request a new token\n     *\n     * @private\n     * @returns {boolean}\n     */\n    TokenManager.prototype.tokenNeedsRefresh = function () {\n        var refreshTime = this.refreshTime;\n        var currentTime = utils_1.getCurrentTime();\n        if (refreshTime && refreshTime > currentTime) {\n            return false;\n        }\n        // Update refreshTime to 60 seconds from now to avoid redundant refreshes\n        this.refreshTime = currentTime + 60;\n        return true;\n    };\n    return TokenManager;\n}());\nexports.TokenManager = TokenManager;\n"]},"metadata":{},"sourceType":"script"}