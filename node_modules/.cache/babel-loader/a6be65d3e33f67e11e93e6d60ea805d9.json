{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Stringify query params, Watson-style\n *\n * Why? The server that processes auth tokens currently only accepts the *exact* string, even if it's invalid for a URL.\n * Properly url-encoding percent characters causes it to reject the token\n * So, this is a custom qs.stringify function that properly encodes everything except watson-token, passing it along verbatim\n *\n * @param {object<string, object>} queryParams\n * @return {String}\n */\n\nvar stringify = function (queryParams) {\n  return Object.keys(queryParams).map(function (key) {\n    return key + '=' + (key === 'watson-token' ? queryParams[key] : encodeURIComponent(queryParams[key])); // the server chokes if the token is correctly url-encoded\n  }).join('&');\n};\n\nexports.default = {\n  stringify: stringify\n};","map":{"version":3,"sources":["/Users/sudesh/Documents/DEV2021/wacode/discovery-components/node_modules/ibm-cloud-sdk-core/lib/querystring.js"],"names":["Object","defineProperty","exports","value","stringify","queryParams","keys","map","key","encodeURIComponent","join","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,SAAS,GAAG,UAAUC,WAAV,EAAuB;AACnC,SAAOL,MAAM,CAACM,IAAP,CAAYD,WAAZ,EACFE,GADE,CACE,UAAUC,GAAV,EAAe;AACpB,WAAQA,GAAG,GACP,GADI,IAEHA,GAAG,KAAK,cAAR,GACKH,WAAW,CAACG,GAAD,CADhB,GAEKC,kBAAkB,CAACJ,WAAW,CAACG,GAAD,CAAZ,CAJpB,CAAR,CADoB,CAK8B;AACrD,GAPM,EAQFE,IARE,CAQG,GARH,CAAP;AASH,CAVD;;AAWAR,OAAO,CAACS,OAAR,GAAkB;AACdP,EAAAA,SAAS,EAAEA;AADG,CAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Stringify query params, Watson-style\n *\n * Why? The server that processes auth tokens currently only accepts the *exact* string, even if it's invalid for a URL.\n * Properly url-encoding percent characters causes it to reject the token\n * So, this is a custom qs.stringify function that properly encodes everything except watson-token, passing it along verbatim\n *\n * @param {object<string, object>} queryParams\n * @return {String}\n */\nvar stringify = function (queryParams) {\n    return Object.keys(queryParams)\n        .map(function (key) {\n        return (key +\n            '=' +\n            (key === 'watson-token'\n                ? queryParams[key]\n                : encodeURIComponent(queryParams[key]))); // the server chokes if the token is correctly url-encoded\n    })\n        .join('&');\n};\nexports.default = {\n    stringify: stringify\n};\n"]},"metadata":{},"sourceType":"script"}