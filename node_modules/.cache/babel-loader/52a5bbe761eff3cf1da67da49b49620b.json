{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _jestGetType = _interopRequireDefault(require('jest-get-type'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// The optional property of matcher context is true if undefined.\n\n\nvar isExpand = function isExpand(expand) {\n  return expand !== false;\n};\n\nvar PRINT_LIMIT = 3;\nvar NO_ARGUMENTS = 'called with 0 arguments';\n\nvar printExpectedArgs = function printExpectedArgs(expected) {\n  return expected.length === 0 ? NO_ARGUMENTS : expected.map(function (arg) {\n    return (0, _jestMatcherUtils.printExpected)(arg);\n  }).join(', ');\n};\n\nvar printReceivedArgs = function printReceivedArgs(received, expected) {\n  return received.length === 0 ? NO_ARGUMENTS : received.map(function (arg, i) {\n    return Array.isArray(expected) && i < expected.length && isEqualValue(expected[i], arg) ? printCommon(arg) : (0, _jestMatcherUtils.printReceived)(arg);\n  }).join(', ');\n};\n\nvar printCommon = function printCommon(val) {\n  return (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));\n};\n\nvar isEqualValue = function isEqualValue(expected, received) {\n  return (0, _jasmineUtils.equals)(expected, received, [_utils.iterableEquality]);\n};\n\nvar isEqualCall = function isEqualCall(expected, received) {\n  return isEqualValue(expected, received);\n};\n\nvar isEqualReturn = function isEqualReturn(expected, result) {\n  return result.type === 'return' && isEqualValue(expected, result.value);\n};\n\nvar countReturns = function countReturns(results) {\n  return results.reduce(function (n, result) {\n    return result.type === 'return' ? n + 1 : n;\n  }, 0);\n};\n\nvar printNumberOfReturns = function printNumberOfReturns(countReturns, countCalls) {\n  return \"\\nNumber of returns: \".concat((0, _jestMatcherUtils.printReceived)(countReturns)) + (countCalls !== countReturns ? \"\\nNumber of calls:   \".concat((0, _jestMatcherUtils.printReceived)(countCalls)) : '');\n}; // Given a label, return a function which given a string,\n// right-aligns it preceding the colon in the label.\n\n\nvar getRightAlignedPrinter = function getRightAlignedPrinter(label) {\n  // Assume that the label contains a colon.\n  var index = label.indexOf(':');\n  var suffix = label.slice(index);\n  return function (string, isExpectedCall) {\n    return (isExpectedCall ? '->' + ' '.repeat(Math.max(0, index - 2 - string.length)) : ' '.repeat(Math.max(index - string.length))) + string + suffix;\n  };\n};\n\nvar printReceivedCallsNegative = function printReceivedCallsNegative(expected, indexedCalls, isOnlyCall, iExpectedCall) {\n  if (indexedCalls.length === 0) {\n    return '';\n  }\n\n  var label = 'Received:     ';\n\n  if (isOnlyCall) {\n    return label + printReceivedArgs(indexedCalls[0], expected) + '\\n';\n  }\n\n  var printAligned = getRightAlignedPrinter(label);\n  return 'Received\\n' + indexedCalls.reduce(function (printed, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        i = _ref2[0],\n        args = _ref2[1];\n\n    return printed + printAligned(String(i + 1), i === iExpectedCall) + printReceivedArgs(args, expected) + '\\n';\n  }, '');\n};\n\nvar printExpectedReceivedCallsPositive = function printExpectedReceivedCallsPositive(expected, indexedCalls, expand, isOnlyCall, iExpectedCall) {\n  var expectedLine = \"Expected: \".concat(printExpectedArgs(expected), \"\\n\");\n\n  if (indexedCalls.length === 0) {\n    return expectedLine;\n  }\n\n  var label = 'Received: ';\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    var received = indexedCalls[0][1];\n\n    if (isLineDiffableCall(expected, received)) {\n      // Display diff without indentation.\n      var lines = [(0, _jestMatcherUtils.EXPECTED_COLOR)('- Expected'), (0, _jestMatcherUtils.RECEIVED_COLOR)('+ Received'), ''];\n      var length = Math.max(expected.length, received.length);\n\n      for (var i = 0; i < length; i += 1) {\n        if (i < expected.length && i < received.length) {\n          if (isEqualValue(expected[i], received[i])) {\n            lines.push(\"  \".concat(printCommon(received[i]), \",\"));\n            continue;\n          }\n\n          if (isLineDiffableArg(expected[i], received[i])) {\n            var difference = (0, _jestMatcherUtils.diff)(expected[i], received[i], {\n              expand: expand\n            });\n\n            if (typeof difference === 'string' && difference.includes('- Expected') && difference.includes('+ Received')) {\n              // Omit annotation in case multiple args have diff.\n              lines.push(difference.split('\\n').slice(3).join('\\n') + ',');\n              continue;\n            }\n          }\n        }\n\n        if (i < expected.length) {\n          lines.push((0, _jestMatcherUtils.EXPECTED_COLOR)('- ' + (0, _jestMatcherUtils.stringify)(expected[i])) + ',');\n        }\n\n        if (i < received.length) {\n          lines.push((0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + (0, _jestMatcherUtils.stringify)(received[i])) + ',');\n        }\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n\n    return expectedLine + label + printReceivedArgs(received, expected) + '\\n';\n  }\n\n  var printAligned = getRightAlignedPrinter(label);\n  return expectedLine + 'Received\\n' + indexedCalls.reduce(function (printed, _ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        i = _ref4[0],\n        received = _ref4[1];\n\n    var aligned = printAligned(String(i + 1), i === iExpectedCall);\n    return printed + ((i === iExpectedCall || iExpectedCall === undefined) && isLineDiffableCall(expected, received) ? aligned.replace(': ', '\\n') + printDiffCall(expected, received, expand) : aligned + printReceivedArgs(received, expected)) + '\\n';\n  }, '');\n};\n\nvar indentation = 'Received'.replace(/\\w/g, ' ');\n\nvar printDiffCall = function printDiffCall(expected, received, expand) {\n  return received.map(function (arg, i) {\n    if (i < expected.length) {\n      if (isEqualValue(expected[i], arg)) {\n        return indentation + '  ' + printCommon(arg) + ',';\n      }\n\n      if (isLineDiffableArg(expected[i], arg)) {\n        var difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {\n          expand: expand\n        });\n\n        if (typeof difference === 'string' && difference.includes('- Expected') && difference.includes('+ Received')) {\n          // Display diff with indentation.\n          // Omit annotation in case multiple args have diff.\n          return difference.split('\\n').slice(3).map(function (line) {\n            return indentation + line;\n          }).join('\\n') + ',';\n        }\n      }\n    } // Display + only if received arg has no corresponding expected arg.\n\n\n    return indentation + (i < expected.length ? '  ' + (0, _jestMatcherUtils.printReceived)(arg) : (0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + (0, _jestMatcherUtils.stringify)(arg))) + ',';\n  }).join('\\n');\n};\n\nvar isLineDiffableCall = function isLineDiffableCall(expected, received) {\n  return expected.some(function (arg, i) {\n    return i < received.length && isLineDiffableArg(arg, received[i]);\n  });\n}; // Almost redundant with function in jest-matcher-utils,\n// except no line diff for any strings.\n\n\nvar isLineDiffableArg = function isLineDiffableArg(expected, received) {\n  var expectedType = (0, _jestGetType.default)(expected);\n  var receivedType = (0, _jestGetType.default)(received);\n\n  if (expectedType !== receivedType) {\n    return false;\n  }\n\n  if (_jestGetType.default.isPrimitive(expected)) {\n    return false;\n  }\n\n  if (expectedType === 'date' || expectedType === 'function' || expectedType === 'regexp') {\n    return false;\n  }\n\n  if (expected instanceof Error && received instanceof Error) {\n    return false;\n  }\n\n  if (expectedType === 'object' && typeof expected.asymmetricMatch === 'function') {\n    return false;\n  }\n\n  if (receivedType === 'object' && typeof received.asymmetricMatch === 'function') {\n    return false;\n  }\n\n  return true;\n};\n\nvar printResult = function printResult(result, expected) {\n  return result.type === 'throw' ? 'function call threw an error' : result.type === 'incomplete' ? 'function call has not returned yet' : isEqualValue(expected, result.value) ? printCommon(result.value) : (0, _jestMatcherUtils.printReceived)(result.value);\n}; // Return either empty string or one line per indexed result,\n// so additional empty line can separate from `Number of returns` which follows.\n\n\nvar printReceivedResults = function printReceivedResults(label, expected, indexedResults, isOnlyCall, iExpectedCall) {\n  if (indexedResults.length === 0) {\n    return '';\n  }\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    return label + printResult(indexedResults[0][1], expected) + '\\n';\n  }\n\n  var printAligned = getRightAlignedPrinter(label);\n  return label.replace(':', '').trim() + '\\n' + indexedResults.reduce(function (printed, _ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n        i = _ref6[0],\n        result = _ref6[1];\n\n    return printed + printAligned(String(i + 1), i === iExpectedCall) + printResult(result, expected) + '\\n';\n  }, '');\n};\n\nvar createToBeCalledMatcher = function createToBeCalledMatcher(matcherName) {\n  return function (received, expected) {\n    var expectedArgument = '';\n    var options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    var receivedIsSpy = isSpy(received);\n    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    var count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;\n    var calls = receivedIsSpy ? received.calls.all().map(function (x) {\n      return x.args;\n    }) : received.mock.calls;\n    var pass = count > 0;\n    var message = pass ? function () {\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of calls: \".concat((0, _jestMatcherUtils.printExpected)(0), \"\\n\") + \"Received number of calls: \".concat((0, _jestMatcherUtils.printReceived)(count), \"\\n\\n\") + calls.reduce(function (lines, args, i) {\n        if (lines.length < PRINT_LIMIT) {\n          lines.push(\"\".concat(i + 1, \": \").concat(printReceivedArgs(args)));\n        }\n\n        return lines;\n      }, []).join('\\n');\n    } : function () {\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of calls: >= \".concat((0, _jestMatcherUtils.printExpected)(1), \"\\n\") + \"Received number of calls:    \".concat((0, _jestMatcherUtils.printReceived)(count));\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createToReturnMatcher = function createToReturnMatcher(matcherName) {\n  return function (received, expected) {\n    var expectedArgument = '';\n    var options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    ensureMock(received, matcherName, expectedArgument, options);\n    var receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n    var count = received.mock.results.reduce(function (n, result) {\n      return result.type === 'return' ? n + 1 : n;\n    }, 0);\n    var pass = count > 0;\n    var message = pass ? function () {\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of returns: \".concat((0, _jestMatcherUtils.printExpected)(0), \"\\n\") + \"Received number of returns: \".concat((0, _jestMatcherUtils.printReceived)(count), \"\\n\\n\") + received.mock.results.reduce(function (lines, result, i) {\n        if (result.type === 'return' && lines.length < PRINT_LIMIT) {\n          lines.push(\"\".concat(i + 1, \": \").concat((0, _jestMatcherUtils.printReceived)(result.value)));\n        }\n\n        return lines;\n      }, []).join('\\n') + (received.mock.calls.length !== count ? \"\\n\\nReceived number of calls:   \".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');\n    } : function () {\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of returns: >= \".concat((0, _jestMatcherUtils.printExpected)(1), \"\\n\") + \"Received number of returns:    \".concat((0, _jestMatcherUtils.printReceived)(count)) + (received.mock.calls.length !== count ? \"\\nReceived number of calls:      \".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createToBeCalledTimesMatcher = function createToBeCalledTimesMatcher(matcherName) {\n  return function (received, expected) {\n    var expectedArgument = 'expected';\n    var options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    var receivedIsSpy = isSpy(received);\n    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    var count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;\n    var pass = count === expected;\n    var message = pass ? function () {\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + \"\\n\\n\" + \"Expected number of calls: not \".concat((0, _jestMatcherUtils.printExpected)(expected));\n    } : function () {\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of calls: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received number of calls: \".concat((0, _jestMatcherUtils.printReceived)(count));\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createToReturnTimesMatcher = function createToReturnTimesMatcher(matcherName) {\n  return function (received, expected) {\n    var expectedArgument = 'expected';\n    var options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);\n    ensureMock(received, matcherName, expectedArgument, options);\n    var receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n    var count = received.mock.results.reduce(function (n, result) {\n      return result.type === 'return' ? n + 1 : n;\n    }, 0);\n    var pass = count === expected;\n    var message = pass ? function () {\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + \"\\n\\n\" + \"Expected number of returns: not \".concat((0, _jestMatcherUtils.printExpected)(expected)) + (received.mock.calls.length !== count ? \"\\n\\nReceived number of calls:       \".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');\n    } : function () {\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected number of returns: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + \"Received number of returns: \".concat((0, _jestMatcherUtils.printReceived)(count)) + (received.mock.calls.length !== count ? \"\\nReceived number of calls:   \".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createToBeCalledWithMatcher = function createToBeCalledWithMatcher(matcherName) {\n  return function (received) {\n    var _this = this;\n\n    for (var _len = arguments.length, expected = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      expected[_key - 1] = arguments[_key];\n    }\n\n    var expectedArgument = '...expected';\n    var options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    var receivedIsSpy = isSpy(received);\n    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    var calls = receivedIsSpy ? received.calls.all().map(function (x) {\n      return x.args;\n    }) : received.mock.calls;\n    var pass = calls.some(function (call) {\n      return isEqualCall(expected, call);\n    });\n    var message = pass ? function () {\n      // Some examples of calls that are equal to expected value.\n      var indexedCalls = [];\n      var i = 0;\n\n      while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n        if (isEqualCall(expected, calls[i])) {\n          indexedCalls.push([i, calls[i]]);\n        }\n\n        i += 1;\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: not \".concat(printExpectedArgs(expected), \"\\n\") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1)) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n    } : function () {\n      // Some examples of calls that are not equal to expected value.\n      var indexedCalls = [];\n      var i = 0;\n\n      while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n        indexedCalls.push([i, calls[i]]);\n        i += 1;\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(_this.expand), calls.length === 1) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createToReturnWithMatcher = function createToReturnWithMatcher(matcherName) {\n  return function (received, expected) {\n    var expectedArgument = 'expected';\n    var options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n    var receivedName = received.getMockName();\n    var _received$mock = received.mock,\n        calls = _received$mock.calls,\n        results = _received$mock.results;\n    var pass = results.some(function (result) {\n      return isEqualReturn(expected, result);\n    });\n    var message = pass ? function () {\n      // Some examples of results that are equal to expected value.\n      var indexedResults = [];\n      var i = 0;\n\n      while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n        if (isEqualReturn(expected, results[i])) {\n          indexedResults.push([i, results[i]]);\n        }\n\n        i += 1;\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1)) + printNumberOfReturns(countReturns(results), calls.length);\n    } : function () {\n      // Some examples of results that are not equal to expected value.\n      var indexedResults = [];\n      var i = 0;\n\n      while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n        indexedResults.push([i, results[i]]);\n        i += 1;\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1) + printNumberOfReturns(countReturns(results), calls.length);\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createLastCalledWithMatcher = function createLastCalledWithMatcher(matcherName) {\n  return function (received) {\n    var _this2 = this;\n\n    for (var _len2 = arguments.length, expected = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      expected[_key2 - 1] = arguments[_key2];\n    }\n\n    var expectedArgument = '...expected';\n    var options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    var receivedIsSpy = isSpy(received);\n    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    var calls = receivedIsSpy ? received.calls.all().map(function (x) {\n      return x.args;\n    }) : received.mock.calls;\n    var iLast = calls.length - 1;\n    var pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);\n    var message = pass ? function () {\n      var indexedCalls = [];\n\n      if (iLast > 0) {\n        // Display preceding call as context.\n        indexedCalls.push([iLast - 1, calls[iLast - 1]]);\n      }\n\n      indexedCalls.push([iLast, calls[iLast]]);\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: not \".concat(printExpectedArgs(expected), \"\\n\") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iLast)) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n    } : function () {\n      var indexedCalls = [];\n\n      if (iLast >= 0) {\n        if (iLast > 0) {\n          var i = iLast - 1; // Is there a preceding call that is equal to expected args?\n\n          while (i >= 0 && !isEqualCall(expected, calls[i])) {\n            i -= 1;\n          }\n\n          if (i < 0) {\n            i = iLast - 1; // otherwise, preceding call\n          }\n\n          indexedCalls.push([i, calls[i]]);\n        }\n\n        indexedCalls.push([iLast, calls[iLast]]);\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(_this2.expand), calls.length === 1, iLast) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createLastReturnedMatcher = function createLastReturnedMatcher(matcherName) {\n  return function (received, expected) {\n    var expectedArgument = 'expected';\n    var options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n    var receivedName = received.getMockName();\n    var _received$mock2 = received.mock,\n        calls = _received$mock2.calls,\n        results = _received$mock2.results;\n    var iLast = results.length - 1;\n    var pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);\n    var message = pass ? function () {\n      var indexedResults = [];\n\n      if (iLast > 0) {\n        // Display preceding result as context.\n        indexedResults.push([iLast - 1, results[iLast - 1]]);\n      }\n\n      indexedResults.push([iLast, results[iLast]]);\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1, iLast)) + printNumberOfReturns(countReturns(results), calls.length);\n    } : function () {\n      var indexedResults = [];\n\n      if (iLast >= 0) {\n        if (iLast > 0) {\n          var i = iLast - 1; // Is there a preceding result that is equal to expected value?\n\n          while (i >= 0 && !isEqualReturn(expected, results[i])) {\n            i -= 1;\n          }\n\n          if (i < 0) {\n            i = iLast - 1; // otherwise, preceding result\n          }\n\n          indexedResults.push([i, results[i]]);\n        }\n\n        indexedResults.push([iLast, results[iLast]]);\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"Expected: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1, iLast) + printNumberOfReturns(countReturns(results), calls.length);\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createNthCalledWithMatcher = function createNthCalledWithMatcher(matcherName) {\n  return function (received, nth) {\n    var _this3 = this;\n\n    for (var _len3 = arguments.length, expected = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      expected[_key3 - 2] = arguments[_key3];\n    }\n\n    var expectedArgument = 'n';\n    var options = {\n      expectedColor: function expectedColor(arg) {\n        return arg;\n      },\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: '...expected'\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n    if (!Number.isSafeInteger(nth) || nth < 1) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat(expectedArgument, \" must be a positive integer\"), (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));\n    }\n\n    var receivedIsSpy = isSpy(received);\n    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    var calls = receivedIsSpy ? received.calls.all().map(function (x) {\n      return x.args;\n    }) : received.mock.calls;\n    var length = calls.length;\n    var iNth = nth - 1;\n    var pass = iNth < length && isEqualCall(expected, calls[iNth]);\n    var message = pass ? function () {\n      // Display preceding and following calls,\n      // in case assertions fails because index is off by one.\n      var indexedCalls = [];\n\n      if (iNth - 1 >= 0) {\n        indexedCalls.push([iNth - 1, calls[iNth - 1]]);\n      }\n\n      indexedCalls.push([iNth, calls[iNth]]);\n\n      if (iNth + 1 < length) {\n        indexedCalls.push([iNth + 1, calls[iNth + 1]]);\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"n: \".concat(nth, \"\\n\") + \"Expected: not \".concat(printExpectedArgs(expected), \"\\n\") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iNth)) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n    } : function () {\n      // Display preceding and following calls:\n      // * nearest call that is equal to expected args\n      // * otherwise, adjacent call\n      // in case assertions fails because of index, especially off by one.\n      var indexedCalls = [];\n\n      if (iNth < length) {\n        if (iNth - 1 >= 0) {\n          var i = iNth - 1; // Is there a preceding call that is equal to expected args?\n\n          while (i >= 0 && !isEqualCall(expected, calls[i])) {\n            i -= 1;\n          }\n\n          if (i < 0) {\n            i = iNth - 1; // otherwise, adjacent call\n          }\n\n          indexedCalls.push([i, calls[i]]);\n        }\n\n        indexedCalls.push([iNth, calls[iNth]]);\n\n        if (iNth + 1 < length) {\n          var _i = iNth + 1; // Is there a following call that is equal to expected args?\n\n\n          while (_i < length && !isEqualCall(expected, calls[_i])) {\n            _i += 1;\n          }\n\n          if (_i >= length) {\n            _i = iNth + 1; // otherwise, adjacent call\n          }\n\n          indexedCalls.push([_i, calls[_i]]);\n        }\n      } else if (length > 0) {\n        // The number of received calls is fewer than the expected number.\n        var _i2 = length - 1; // Is there a call that is equal to expected args?\n\n\n        while (_i2 >= 0 && !isEqualCall(expected, calls[_i2])) {\n          _i2 -= 1;\n        }\n\n        if (_i2 < 0) {\n          _i2 = length - 1; // otherwise, last call\n        }\n\n        indexedCalls.push([_i2, calls[_i2]]);\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"n: \".concat(nth, \"\\n\") + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(_this3.expand), calls.length === 1, iNth) + \"\\nNumber of calls: \".concat((0, _jestMatcherUtils.printReceived)(calls.length));\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar createNthReturnedWithMatcher = function createNthReturnedWithMatcher(matcherName) {\n  return function (received, nth, expected) {\n    var expectedArgument = 'n';\n    var options = {\n      expectedColor: function expectedColor(arg) {\n        return arg;\n      },\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: 'expected'\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n\n    if (!Number.isSafeInteger(nth) || nth < 1) {\n      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat(expectedArgument, \" must be a positive integer\"), (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));\n    }\n\n    var receivedName = received.getMockName();\n    var _received$mock3 = received.mock,\n        calls = _received$mock3.calls,\n        results = _received$mock3.results;\n    var length = results.length;\n    var iNth = nth - 1;\n    var pass = iNth < length && isEqualReturn(expected, results[iNth]);\n    var message = pass ? function () {\n      // Display preceding and following results,\n      // in case assertions fails because index is off by one.\n      var indexedResults = [];\n\n      if (iNth - 1 >= 0) {\n        indexedResults.push([iNth - 1, results[iNth - 1]]);\n      }\n\n      indexedResults.push([iNth, results[iNth]]);\n\n      if (iNth + 1 < length) {\n        indexedResults.push([iNth + 1, results[iNth + 1]]);\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"n: \".concat(nth, \"\\n\") + \"Expected: not \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1, iNth)) + printNumberOfReturns(countReturns(results), calls.length);\n    } : function () {\n      // Display preceding and following results:\n      // * nearest result that is equal to expected value\n      // * otherwise, adjacent result\n      // in case assertions fails because of index, especially off by one.\n      var indexedResults = [];\n\n      if (iNth < length) {\n        if (iNth - 1 >= 0) {\n          var i = iNth - 1; // Is there a preceding result that is equal to expected value?\n\n          while (i >= 0 && !isEqualReturn(expected, results[i])) {\n            i -= 1;\n          }\n\n          if (i < 0) {\n            i = iNth - 1; // otherwise, adjacent result\n          }\n\n          indexedResults.push([i, results[i]]);\n        }\n\n        indexedResults.push([iNth, results[iNth]]);\n\n        if (iNth + 1 < length) {\n          var _i3 = iNth + 1; // Is there a following result that is equal to expected value?\n\n\n          while (_i3 < length && !isEqualReturn(expected, results[_i3])) {\n            _i3 += 1;\n          }\n\n          if (_i3 >= length) {\n            _i3 = iNth + 1; // otherwise, adjacent result\n          }\n\n          indexedResults.push([_i3, results[_i3]]);\n        }\n      } else if (length > 0) {\n        // The number of received calls is fewer than the expected number.\n        var _i4 = length - 1; // Is there a result that is equal to expected value?\n\n\n        while (_i4 >= 0 && !isEqualReturn(expected, results[_i4])) {\n          _i4 -= 1;\n        }\n\n        if (_i4 < 0) {\n          _i4 = length - 1; // otherwise, last result\n        }\n\n        indexedResults.push([_i4, results[_i4]]);\n      }\n\n      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\\n\\n' + \"n: \".concat(nth, \"\\n\") + \"Expected: \".concat((0, _jestMatcherUtils.printExpected)(expected), \"\\n\") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1, iNth) + printNumberOfReturns(countReturns(results), calls.length);\n    };\n    return {\n      message: message,\n      pass: pass\n    };\n  };\n};\n\nvar spyMatchers = {\n  lastCalledWith: createLastCalledWithMatcher('lastCalledWith'),\n  lastReturnedWith: createLastReturnedMatcher('lastReturnedWith'),\n  nthCalledWith: createNthCalledWithMatcher('nthCalledWith'),\n  nthReturnedWith: createNthReturnedWithMatcher('nthReturnedWith'),\n  toBeCalled: createToBeCalledMatcher('toBeCalled'),\n  toBeCalledTimes: createToBeCalledTimesMatcher('toBeCalledTimes'),\n  toBeCalledWith: createToBeCalledWithMatcher('toBeCalledWith'),\n  toHaveBeenCalled: createToBeCalledMatcher('toHaveBeenCalled'),\n  toHaveBeenCalledTimes: createToBeCalledTimesMatcher('toHaveBeenCalledTimes'),\n  toHaveBeenCalledWith: createToBeCalledWithMatcher('toHaveBeenCalledWith'),\n  toHaveBeenLastCalledWith: createLastCalledWithMatcher('toHaveBeenLastCalledWith'),\n  toHaveBeenNthCalledWith: createNthCalledWithMatcher('toHaveBeenNthCalledWith'),\n  toHaveLastReturnedWith: createLastReturnedMatcher('toHaveLastReturnedWith'),\n  toHaveNthReturnedWith: createNthReturnedWithMatcher('toHaveNthReturnedWith'),\n  toHaveReturned: createToReturnMatcher('toHaveReturned'),\n  toHaveReturnedTimes: createToReturnTimesMatcher('toHaveReturnedTimes'),\n  toHaveReturnedWith: createToReturnWithMatcher('toHaveReturnedWith'),\n  toReturn: createToReturnMatcher('toReturn'),\n  toReturnTimes: createToReturnTimesMatcher('toReturnTimes'),\n  toReturnWith: createToReturnWithMatcher('toReturnWith')\n};\n\nvar isMock = function isMock(received) {\n  return received != null && received._isMockFunction === true;\n};\n\nvar isSpy = function isSpy(received) {\n  return received != null && received.calls != null && typeof received.calls.all === 'function' && typeof received.calls.count === 'function';\n};\n\nvar ensureMockOrSpy = function ensureMockOrSpy(received, matcherName, expectedArgument, options) {\n  if (!isMock(received) && !isSpy(received)) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must be a mock or spy function\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n  }\n};\n\nvar ensureMock = function ensureMock(received, matcherName, expectedArgument, options) {\n  if (!isMock(received)) {\n    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), \"\".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), \" value must be a mock function\"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));\n  }\n};\n\nvar _default = spyMatchers;\nexports.default = _default;","map":{"version":3,"sources":["/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/ibm-cloud-sdk-core/node_modules/expect/build/spyMatchers.js"],"names":["Object","defineProperty","exports","value","default","_jestGetType","_interopRequireDefault","require","_jestMatcherUtils","_jasmineUtils","_utils","obj","__esModule","isExpand","expand","PRINT_LIMIT","NO_ARGUMENTS","printExpectedArgs","expected","length","map","arg","printExpected","join","printReceivedArgs","received","i","Array","isArray","isEqualValue","printCommon","printReceived","val","DIM_COLOR","stringify","equals","iterableEquality","isEqualCall","isEqualReturn","result","type","countReturns","results","reduce","n","printNumberOfReturns","countCalls","getRightAlignedPrinter","label","index","indexOf","suffix","slice","string","isExpectedCall","repeat","Math","max","printReceivedCallsNegative","indexedCalls","isOnlyCall","iExpectedCall","printAligned","printed","args","String","printExpectedReceivedCallsPositive","expectedLine","undefined","isLineDiffableCall","lines","EXPECTED_COLOR","RECEIVED_COLOR","push","isLineDiffableArg","difference","diff","includes","split","aligned","replace","printDiffCall","indentation","line","some","expectedType","receivedType","isPrimitive","Error","asymmetricMatch","printResult","printReceivedResults","indexedResults","trim","createToBeCalledMatcher","matcherName","expectedArgument","options","isNot","promise","ensureNoExpected","ensureMockOrSpy","receivedIsSpy","isSpy","receivedName","getMockName","count","calls","mock","all","x","pass","message","matcherHint","createToReturnMatcher","ensureMock","createToBeCalledTimesMatcher","ensureExpectedIsNonNegativeInteger","createToReturnTimesMatcher","createToBeCalledWithMatcher","call","createToReturnWithMatcher","createLastCalledWithMatcher","iLast","createLastReturnedMatcher","createNthCalledWithMatcher","nth","expectedColor","secondArgument","Number","isSafeInteger","matcherErrorMessage","printWithType","iNth","createNthReturnedWithMatcher","spyMatchers","lastCalledWith","lastReturnedWith","nthCalledWith","nthReturnedWith","toBeCalled","toBeCalledTimes","toBeCalledWith","toHaveBeenCalled","toHaveBeenCalledTimes","toHaveBeenCalledWith","toHaveBeenLastCalledWith","toHaveBeenNthCalledWith","toHaveLastReturnedWith","toHaveNthReturnedWith","toHaveReturned","toHaveReturnedTimes","toHaveReturnedWith","toReturn","toReturnTimes","toReturnWith","isMock","_isMockFunction","_default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _jestGetType = _interopRequireDefault(require('jest-get-type'));\n\nvar _jestMatcherUtils = require('jest-matcher-utils');\n\nvar _jasmineUtils = require('./jasmineUtils');\n\nvar _utils = require('./utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n// The optional property of matcher context is true if undefined.\nconst isExpand = expand => expand !== false;\n\nconst PRINT_LIMIT = 3;\nconst NO_ARGUMENTS = 'called with 0 arguments';\n\nconst printExpectedArgs = expected =>\n  expected.length === 0\n    ? NO_ARGUMENTS\n    : expected.map(arg => (0, _jestMatcherUtils.printExpected)(arg)).join(', ');\n\nconst printReceivedArgs = (received, expected) =>\n  received.length === 0\n    ? NO_ARGUMENTS\n    : received\n        .map((arg, i) =>\n          Array.isArray(expected) &&\n          i < expected.length &&\n          isEqualValue(expected[i], arg)\n            ? printCommon(arg)\n            : (0, _jestMatcherUtils.printReceived)(arg)\n        )\n        .join(', ');\n\nconst printCommon = val =>\n  (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));\n\nconst isEqualValue = (expected, received) =>\n  (0, _jasmineUtils.equals)(expected, received, [_utils.iterableEquality]);\n\nconst isEqualCall = (expected, received) => isEqualValue(expected, received);\n\nconst isEqualReturn = (expected, result) =>\n  result.type === 'return' && isEqualValue(expected, result.value);\n\nconst countReturns = results =>\n  results.reduce((n, result) => (result.type === 'return' ? n + 1 : n), 0);\n\nconst printNumberOfReturns = (countReturns, countCalls) =>\n  `\\nNumber of returns: ${(0, _jestMatcherUtils.printReceived)(countReturns)}` +\n  (countCalls !== countReturns\n    ? `\\nNumber of calls:   ${(0, _jestMatcherUtils.printReceived)(countCalls)}`\n    : '');\n\n// Given a label, return a function which given a string,\n// right-aligns it preceding the colon in the label.\nconst getRightAlignedPrinter = label => {\n  // Assume that the label contains a colon.\n  const index = label.indexOf(':');\n  const suffix = label.slice(index);\n  return (string, isExpectedCall) =>\n    (isExpectedCall\n      ? '->' + ' '.repeat(Math.max(0, index - 2 - string.length))\n      : ' '.repeat(Math.max(index - string.length))) +\n    string +\n    suffix;\n};\n\nconst printReceivedCallsNegative = (\n  expected,\n  indexedCalls,\n  isOnlyCall,\n  iExpectedCall\n) => {\n  if (indexedCalls.length === 0) {\n    return '';\n  }\n\n  const label = 'Received:     ';\n\n  if (isOnlyCall) {\n    return label + printReceivedArgs(indexedCalls[0], expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return (\n    'Received\\n' +\n    indexedCalls.reduce(\n      (printed, [i, args]) =>\n        printed +\n        printAligned(String(i + 1), i === iExpectedCall) +\n        printReceivedArgs(args, expected) +\n        '\\n',\n      ''\n    )\n  );\n};\n\nconst printExpectedReceivedCallsPositive = (\n  expected,\n  indexedCalls,\n  expand,\n  isOnlyCall,\n  iExpectedCall\n) => {\n  const expectedLine = `Expected: ${printExpectedArgs(expected)}\\n`;\n\n  if (indexedCalls.length === 0) {\n    return expectedLine;\n  }\n\n  const label = 'Received: ';\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    const received = indexedCalls[0][1];\n\n    if (isLineDiffableCall(expected, received)) {\n      // Display diff without indentation.\n      const lines = [\n        (0, _jestMatcherUtils.EXPECTED_COLOR)('- Expected'),\n        (0, _jestMatcherUtils.RECEIVED_COLOR)('+ Received'),\n        ''\n      ];\n      const length = Math.max(expected.length, received.length);\n\n      for (let i = 0; i < length; i += 1) {\n        if (i < expected.length && i < received.length) {\n          if (isEqualValue(expected[i], received[i])) {\n            lines.push(`  ${printCommon(received[i])},`);\n            continue;\n          }\n\n          if (isLineDiffableArg(expected[i], received[i])) {\n            const difference = (0, _jestMatcherUtils.diff)(\n              expected[i],\n              received[i],\n              {\n                expand\n              }\n            );\n\n            if (\n              typeof difference === 'string' &&\n              difference.includes('- Expected') &&\n              difference.includes('+ Received')\n            ) {\n              // Omit annotation in case multiple args have diff.\n              lines.push(difference.split('\\n').slice(3).join('\\n') + ',');\n              continue;\n            }\n          }\n        }\n\n        if (i < expected.length) {\n          lines.push(\n            (0, _jestMatcherUtils.EXPECTED_COLOR)(\n              '- ' + (0, _jestMatcherUtils.stringify)(expected[i])\n            ) + ','\n          );\n        }\n\n        if (i < received.length) {\n          lines.push(\n            (0, _jestMatcherUtils.RECEIVED_COLOR)(\n              '+ ' + (0, _jestMatcherUtils.stringify)(received[i])\n            ) + ','\n          );\n        }\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n\n    return expectedLine + label + printReceivedArgs(received, expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return (\n    expectedLine +\n    'Received\\n' +\n    indexedCalls.reduce((printed, [i, received]) => {\n      const aligned = printAligned(String(i + 1), i === iExpectedCall);\n      return (\n        printed +\n        ((i === iExpectedCall || iExpectedCall === undefined) &&\n        isLineDiffableCall(expected, received)\n          ? aligned.replace(': ', '\\n') +\n            printDiffCall(expected, received, expand)\n          : aligned + printReceivedArgs(received, expected)) +\n        '\\n'\n      );\n    }, '')\n  );\n};\n\nconst indentation = 'Received'.replace(/\\w/g, ' ');\n\nconst printDiffCall = (expected, received, expand) =>\n  received\n    .map((arg, i) => {\n      if (i < expected.length) {\n        if (isEqualValue(expected[i], arg)) {\n          return indentation + '  ' + printCommon(arg) + ',';\n        }\n\n        if (isLineDiffableArg(expected[i], arg)) {\n          const difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {\n            expand\n          });\n\n          if (\n            typeof difference === 'string' &&\n            difference.includes('- Expected') &&\n            difference.includes('+ Received')\n          ) {\n            // Display diff with indentation.\n            // Omit annotation in case multiple args have diff.\n            return (\n              difference\n                .split('\\n')\n                .slice(3)\n                .map(line => indentation + line)\n                .join('\\n') + ','\n            );\n          }\n        }\n      } // Display + only if received arg has no corresponding expected arg.\n\n      return (\n        indentation +\n        (i < expected.length\n          ? '  ' + (0, _jestMatcherUtils.printReceived)(arg)\n          : (0, _jestMatcherUtils.RECEIVED_COLOR)(\n              '+ ' + (0, _jestMatcherUtils.stringify)(arg)\n            )) +\n        ','\n      );\n    })\n    .join('\\n');\n\nconst isLineDiffableCall = (expected, received) =>\n  expected.some(\n    (arg, i) => i < received.length && isLineDiffableArg(arg, received[i])\n  ); // Almost redundant with function in jest-matcher-utils,\n// except no line diff for any strings.\n\nconst isLineDiffableArg = (expected, received) => {\n  const expectedType = (0, _jestGetType.default)(expected);\n  const receivedType = (0, _jestGetType.default)(received);\n\n  if (expectedType !== receivedType) {\n    return false;\n  }\n\n  if (_jestGetType.default.isPrimitive(expected)) {\n    return false;\n  }\n\n  if (\n    expectedType === 'date' ||\n    expectedType === 'function' ||\n    expectedType === 'regexp'\n  ) {\n    return false;\n  }\n\n  if (expected instanceof Error && received instanceof Error) {\n    return false;\n  }\n\n  if (\n    expectedType === 'object' &&\n    typeof expected.asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  if (\n    receivedType === 'object' &&\n    typeof received.asymmetricMatch === 'function'\n  ) {\n    return false;\n  }\n\n  return true;\n};\n\nconst printResult = (result, expected) =>\n  result.type === 'throw'\n    ? 'function call threw an error'\n    : result.type === 'incomplete'\n    ? 'function call has not returned yet'\n    : isEqualValue(expected, result.value)\n    ? printCommon(result.value)\n    : (0, _jestMatcherUtils.printReceived)(result.value);\n\n// Return either empty string or one line per indexed result,\n// so additional empty line can separate from `Number of returns` which follows.\nconst printReceivedResults = (\n  label,\n  expected,\n  indexedResults,\n  isOnlyCall,\n  iExpectedCall\n) => {\n  if (indexedResults.length === 0) {\n    return '';\n  }\n\n  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {\n    return label + printResult(indexedResults[0][1], expected) + '\\n';\n  }\n\n  const printAligned = getRightAlignedPrinter(label);\n  return (\n    label.replace(':', '').trim() +\n    '\\n' +\n    indexedResults.reduce(\n      (printed, [i, result]) =>\n        printed +\n        printAligned(String(i + 1), i === iExpectedCall) +\n        printResult(result, expected) +\n        '\\n',\n      ''\n    )\n  );\n};\n\nconst createToBeCalledMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = '';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const count = receivedIsSpy\n      ? received.calls.count()\n      : received.mock.calls.length;\n    const calls = receivedIsSpy\n      ? received.calls.all().map(x => x.args)\n      : received.mock.calls;\n    const pass = count > 0;\n    const message = pass\n      ? () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(\n            0\n          )}\\n` +\n          `Received number of calls: ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}\\n\\n` +\n          calls\n            .reduce((lines, args, i) => {\n              if (lines.length < PRINT_LIMIT) {\n                lines.push(`${i + 1}: ${printReceivedArgs(args)}`);\n              }\n\n              return lines;\n            }, [])\n            .join('\\n')\n      : () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: >= ${(0, _jestMatcherUtils.printExpected)(\n            1\n          )}\\n` +\n          `Received number of calls:    ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}`;\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToReturnMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = '';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);\n    ensureMock(received, matcherName, expectedArgument, options);\n    const receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n    const count = received.mock.results.reduce(\n      (n, result) => (result.type === 'return' ? n + 1 : n),\n      0\n    );\n    const pass = count > 0;\n    const message = pass\n      ? () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(\n            0\n          )}\\n` +\n          `Received number of returns: ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}\\n\\n` +\n          received.mock.results\n            .reduce((lines, result, i) => {\n              if (result.type === 'return' && lines.length < PRINT_LIMIT) {\n                lines.push(\n                  `${i + 1}: ${(0, _jestMatcherUtils.printReceived)(\n                    result.value\n                  )}`\n                );\n              }\n\n              return lines;\n            }, [])\n            .join('\\n') +\n          (received.mock.calls.length !== count\n            ? `\\n\\nReceived number of calls:   ${(0,\n              _jestMatcherUtils.printReceived)(received.mock.calls.length)}`\n            : '')\n      : () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: >= ${(0,\n          _jestMatcherUtils.printExpected)(1)}\\n` +\n          `Received number of returns:    ${(0,\n          _jestMatcherUtils.printReceived)(count)}` +\n          (received.mock.calls.length !== count\n            ? `\\nReceived number of calls:      ${(0,\n              _jestMatcherUtils.printReceived)(received.mock.calls.length)}`\n            : '');\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToBeCalledTimesMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = 'expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(\n      expected,\n      matcherName,\n      options\n    );\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const count = receivedIsSpy\n      ? received.calls.count()\n      : received.mock.calls.length;\n    const pass = count === expected;\n    const message = pass\n      ? () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          `\\n\\n` +\n          `Expected number of calls: not ${(0, _jestMatcherUtils.printExpected)(\n            expected\n          )}`\n      : () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of calls: ${(0, _jestMatcherUtils.printExpected)(\n            expected\n          )}\\n` +\n          `Received number of calls: ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}`;\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToReturnTimesMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = 'expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(\n      expected,\n      matcherName,\n      options\n    );\n    ensureMock(received, matcherName, expectedArgument, options);\n    const receivedName = received.getMockName(); // Count return values that correspond only to calls that returned\n\n    const count = received.mock.results.reduce(\n      (n, result) => (result.type === 'return' ? n + 1 : n),\n      0\n    );\n    const pass = count === expected;\n    const message = pass\n      ? () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          `\\n\\n` +\n          `Expected number of returns: not ${(0,\n          _jestMatcherUtils.printExpected)(expected)}` +\n          (received.mock.calls.length !== count\n            ? `\\n\\nReceived number of calls:       ${(0,\n              _jestMatcherUtils.printReceived)(received.mock.calls.length)}`\n            : '')\n      : () =>\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            receivedName,\n            expectedArgument,\n            options\n          ) +\n          '\\n\\n' +\n          `Expected number of returns: ${(0, _jestMatcherUtils.printExpected)(\n            expected\n          )}\\n` +\n          `Received number of returns: ${(0, _jestMatcherUtils.printReceived)(\n            count\n          )}` +\n          (received.mock.calls.length !== count\n            ? `\\nReceived number of calls:   ${(0,\n              _jestMatcherUtils.printReceived)(received.mock.calls.length)}`\n            : '');\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToBeCalledWithMatcher = matcherName =>\n  function (received, ...expected) {\n    const expectedArgument = '...expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const calls = receivedIsSpy\n      ? received.calls.all().map(x => x.args)\n      : received.mock.calls;\n    const pass = calls.some(call => isEqualCall(expected, call));\n    const message = pass\n      ? () => {\n          // Some examples of calls that are equal to expected value.\n          const indexedCalls = [];\n          let i = 0;\n\n          while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n            if (isEqualCall(expected, calls[i])) {\n              indexedCalls.push([i, calls[i]]);\n            }\n\n            i += 1;\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 &&\n            (0, _jestMatcherUtils.stringify)(calls[0]) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1\n                )) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        }\n      : () => {\n          // Some examples of calls that are not equal to expected value.\n          const indexedCalls = [];\n          let i = 0;\n\n          while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {\n            indexedCalls.push([i, calls[i]]);\n            i += 1;\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1\n            ) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createToReturnWithMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = 'expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n    const receivedName = received.getMockName();\n    const {calls, results} = received.mock;\n    const pass = results.some(result => isEqualReturn(expected, result));\n    const message = pass\n      ? () => {\n          // Some examples of results that are equal to expected value.\n          const indexedResults = [];\n          let i = 0;\n\n          while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n            if (isEqualReturn(expected, results[i])) {\n              indexedResults.push([i, results[i]]);\n            }\n\n            i += 1;\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: not ${(0, _jestMatcherUtils.printExpected)(\n              expected\n            )}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            (0, _jestMatcherUtils.stringify)(results[0].value) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          // Some examples of results that are not equal to expected value.\n          const indexedResults = [];\n          let i = 0;\n\n          while (i < results.length && indexedResults.length < PRINT_LIMIT) {\n            indexedResults.push([i, results[i]]);\n            i += 1;\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createLastCalledWithMatcher = matcherName =>\n  function (received, ...expected) {\n    const expectedArgument = '...expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const calls = receivedIsSpy\n      ? received.calls.all().map(x => x.args)\n      : received.mock.calls;\n    const iLast = calls.length - 1;\n    const pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);\n    const message = pass\n      ? () => {\n          const indexedCalls = [];\n\n          if (iLast > 0) {\n            // Display preceding call as context.\n            indexedCalls.push([iLast - 1, calls[iLast - 1]]);\n          }\n\n          indexedCalls.push([iLast, calls[iLast]]);\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 &&\n            (0, _jestMatcherUtils.stringify)(calls[0]) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1,\n                  iLast\n                )) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        }\n      : () => {\n          const indexedCalls = [];\n\n          if (iLast >= 0) {\n            if (iLast > 0) {\n              let i = iLast - 1; // Is there a preceding call that is equal to expected args?\n\n              while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                i -= 1;\n              }\n\n              if (i < 0) {\n                i = iLast - 1; // otherwise, preceding call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n\n            indexedCalls.push([iLast, calls[iLast]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1,\n              iLast\n            ) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createLastReturnedMatcher = matcherName =>\n  function (received, expected) {\n    const expectedArgument = 'expected';\n    const options = {\n      isNot: this.isNot,\n      promise: this.promise\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n    const receivedName = received.getMockName();\n    const {calls, results} = received.mock;\n    const iLast = results.length - 1;\n    const pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);\n    const message = pass\n      ? () => {\n          const indexedResults = [];\n\n          if (iLast > 0) {\n            // Display preceding result as context.\n            indexedResults.push([iLast - 1, results[iLast - 1]]);\n          }\n\n          indexedResults.push([iLast, results[iLast]]);\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: not ${(0, _jestMatcherUtils.printExpected)(\n              expected\n            )}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            (0, _jestMatcherUtils.stringify)(results[0].value) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1,\n                  iLast\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          const indexedResults = [];\n\n          if (iLast >= 0) {\n            if (iLast > 0) {\n              let i = iLast - 1; // Is there a preceding result that is equal to expected value?\n\n              while (i >= 0 && !isEqualReturn(expected, results[i])) {\n                i -= 1;\n              }\n\n              if (i < 0) {\n                i = iLast - 1; // otherwise, preceding result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n\n            indexedResults.push([iLast, results[iLast]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1,\n              iLast\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createNthCalledWithMatcher = matcherName =>\n  function (received, nth, ...expected) {\n    const expectedArgument = 'n';\n    const options = {\n      expectedColor: arg => arg,\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: '...expected'\n    };\n    ensureMockOrSpy(received, matcherName, expectedArgument, options);\n\n    if (!Number.isSafeInteger(nth) || nth < 1) {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            expectedArgument,\n            options\n          ),\n          `${expectedArgument} must be a positive integer`,\n          (0, _jestMatcherUtils.printWithType)(\n            expectedArgument,\n            nth,\n            _jestMatcherUtils.stringify\n          )\n        )\n      );\n    }\n\n    const receivedIsSpy = isSpy(received);\n    const receivedName = receivedIsSpy ? 'spy' : received.getMockName();\n    const calls = receivedIsSpy\n      ? received.calls.all().map(x => x.args)\n      : received.mock.calls;\n    const length = calls.length;\n    const iNth = nth - 1;\n    const pass = iNth < length && isEqualCall(expected, calls[iNth]);\n    const message = pass\n      ? () => {\n          // Display preceding and following calls,\n          // in case assertions fails because index is off by one.\n          const indexedCalls = [];\n\n          if (iNth - 1 >= 0) {\n            indexedCalls.push([iNth - 1, calls[iNth - 1]]);\n          }\n\n          indexedCalls.push([iNth, calls[iNth]]);\n\n          if (iNth + 1 < length) {\n            indexedCalls.push([iNth + 1, calls[iNth + 1]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: not ${printExpectedArgs(expected)}\\n` +\n            (calls.length === 1 &&\n            (0, _jestMatcherUtils.stringify)(calls[0]) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedCallsNegative(\n                  expected,\n                  indexedCalls,\n                  calls.length === 1,\n                  iNth\n                )) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        }\n      : () => {\n          // Display preceding and following calls:\n          // * nearest call that is equal to expected args\n          // * otherwise, adjacent call\n          // in case assertions fails because of index, especially off by one.\n          const indexedCalls = [];\n\n          if (iNth < length) {\n            if (iNth - 1 >= 0) {\n              let i = iNth - 1; // Is there a preceding call that is equal to expected args?\n\n              while (i >= 0 && !isEqualCall(expected, calls[i])) {\n                i -= 1;\n              }\n\n              if (i < 0) {\n                i = iNth - 1; // otherwise, adjacent call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n\n            indexedCalls.push([iNth, calls[iNth]]);\n\n            if (iNth + 1 < length) {\n              let i = iNth + 1; // Is there a following call that is equal to expected args?\n\n              while (i < length && !isEqualCall(expected, calls[i])) {\n                i += 1;\n              }\n\n              if (i >= length) {\n                i = iNth + 1; // otherwise, adjacent call\n              }\n\n              indexedCalls.push([i, calls[i]]);\n            }\n          } else if (length > 0) {\n            // The number of received calls is fewer than the expected number.\n            let i = length - 1; // Is there a call that is equal to expected args?\n\n            while (i >= 0 && !isEqualCall(expected, calls[i])) {\n              i -= 1;\n            }\n\n            if (i < 0) {\n              i = length - 1; // otherwise, last call\n            }\n\n            indexedCalls.push([i, calls[i]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            printExpectedReceivedCallsPositive(\n              expected,\n              indexedCalls,\n              isExpand(this.expand),\n              calls.length === 1,\n              iNth\n            ) +\n            `\\nNumber of calls: ${(0, _jestMatcherUtils.printReceived)(\n              calls.length\n            )}`\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst createNthReturnedWithMatcher = matcherName =>\n  function (received, nth, expected) {\n    const expectedArgument = 'n';\n    const options = {\n      expectedColor: arg => arg,\n      isNot: this.isNot,\n      promise: this.promise,\n      secondArgument: 'expected'\n    };\n    ensureMock(received, matcherName, expectedArgument, options);\n\n    if (!Number.isSafeInteger(nth) || nth < 1) {\n      throw new Error(\n        (0, _jestMatcherUtils.matcherErrorMessage)(\n          (0, _jestMatcherUtils.matcherHint)(\n            matcherName,\n            undefined,\n            expectedArgument,\n            options\n          ),\n          `${expectedArgument} must be a positive integer`,\n          (0, _jestMatcherUtils.printWithType)(\n            expectedArgument,\n            nth,\n            _jestMatcherUtils.stringify\n          )\n        )\n      );\n    }\n\n    const receivedName = received.getMockName();\n    const {calls, results} = received.mock;\n    const length = results.length;\n    const iNth = nth - 1;\n    const pass = iNth < length && isEqualReturn(expected, results[iNth]);\n    const message = pass\n      ? () => {\n          // Display preceding and following results,\n          // in case assertions fails because index is off by one.\n          const indexedResults = [];\n\n          if (iNth - 1 >= 0) {\n            indexedResults.push([iNth - 1, results[iNth - 1]]);\n          }\n\n          indexedResults.push([iNth, results[iNth]]);\n\n          if (iNth + 1 < length) {\n            indexedResults.push([iNth + 1, results[iNth + 1]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: not ${(0, _jestMatcherUtils.printExpected)(\n              expected\n            )}\\n` +\n            (results.length === 1 &&\n            results[0].type === 'return' &&\n            (0, _jestMatcherUtils.stringify)(results[0].value) ===\n              (0, _jestMatcherUtils.stringify)(expected)\n              ? ''\n              : printReceivedResults(\n                  'Received:     ',\n                  expected,\n                  indexedResults,\n                  results.length === 1,\n                  iNth\n                )) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        }\n      : () => {\n          // Display preceding and following results:\n          // * nearest result that is equal to expected value\n          // * otherwise, adjacent result\n          // in case assertions fails because of index, especially off by one.\n          const indexedResults = [];\n\n          if (iNth < length) {\n            if (iNth - 1 >= 0) {\n              let i = iNth - 1; // Is there a preceding result that is equal to expected value?\n\n              while (i >= 0 && !isEqualReturn(expected, results[i])) {\n                i -= 1;\n              }\n\n              if (i < 0) {\n                i = iNth - 1; // otherwise, adjacent result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n\n            indexedResults.push([iNth, results[iNth]]);\n\n            if (iNth + 1 < length) {\n              let i = iNth + 1; // Is there a following result that is equal to expected value?\n\n              while (i < length && !isEqualReturn(expected, results[i])) {\n                i += 1;\n              }\n\n              if (i >= length) {\n                i = iNth + 1; // otherwise, adjacent result\n              }\n\n              indexedResults.push([i, results[i]]);\n            }\n          } else if (length > 0) {\n            // The number of received calls is fewer than the expected number.\n            let i = length - 1; // Is there a result that is equal to expected value?\n\n            while (i >= 0 && !isEqualReturn(expected, results[i])) {\n              i -= 1;\n            }\n\n            if (i < 0) {\n              i = length - 1; // otherwise, last result\n            }\n\n            indexedResults.push([i, results[i]]);\n          }\n\n          return (\n            (0, _jestMatcherUtils.matcherHint)(\n              matcherName,\n              receivedName,\n              expectedArgument,\n              options\n            ) +\n            '\\n\\n' +\n            `n: ${nth}\\n` +\n            `Expected: ${(0, _jestMatcherUtils.printExpected)(expected)}\\n` +\n            printReceivedResults(\n              'Received: ',\n              expected,\n              indexedResults,\n              results.length === 1,\n              iNth\n            ) +\n            printNumberOfReturns(countReturns(results), calls.length)\n          );\n        };\n    return {\n      message,\n      pass\n    };\n  };\n\nconst spyMatchers = {\n  lastCalledWith: createLastCalledWithMatcher('lastCalledWith'),\n  lastReturnedWith: createLastReturnedMatcher('lastReturnedWith'),\n  nthCalledWith: createNthCalledWithMatcher('nthCalledWith'),\n  nthReturnedWith: createNthReturnedWithMatcher('nthReturnedWith'),\n  toBeCalled: createToBeCalledMatcher('toBeCalled'),\n  toBeCalledTimes: createToBeCalledTimesMatcher('toBeCalledTimes'),\n  toBeCalledWith: createToBeCalledWithMatcher('toBeCalledWith'),\n  toHaveBeenCalled: createToBeCalledMatcher('toHaveBeenCalled'),\n  toHaveBeenCalledTimes: createToBeCalledTimesMatcher('toHaveBeenCalledTimes'),\n  toHaveBeenCalledWith: createToBeCalledWithMatcher('toHaveBeenCalledWith'),\n  toHaveBeenLastCalledWith: createLastCalledWithMatcher(\n    'toHaveBeenLastCalledWith'\n  ),\n  toHaveBeenNthCalledWith: createNthCalledWithMatcher(\n    'toHaveBeenNthCalledWith'\n  ),\n  toHaveLastReturnedWith: createLastReturnedMatcher('toHaveLastReturnedWith'),\n  toHaveNthReturnedWith: createNthReturnedWithMatcher('toHaveNthReturnedWith'),\n  toHaveReturned: createToReturnMatcher('toHaveReturned'),\n  toHaveReturnedTimes: createToReturnTimesMatcher('toHaveReturnedTimes'),\n  toHaveReturnedWith: createToReturnWithMatcher('toHaveReturnedWith'),\n  toReturn: createToReturnMatcher('toReturn'),\n  toReturnTimes: createToReturnTimesMatcher('toReturnTimes'),\n  toReturnWith: createToReturnWithMatcher('toReturnWith')\n};\n\nconst isMock = received =>\n  received != null && received._isMockFunction === true;\n\nconst isSpy = received =>\n  received != null &&\n  received.calls != null &&\n  typeof received.calls.all === 'function' &&\n  typeof received.calls.count === 'function';\n\nconst ensureMockOrSpy = (received, matcherName, expectedArgument, options) => {\n  if (!isMock(received) && !isSpy(received)) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _jestMatcherUtils.matcherHint)(\n          matcherName,\n          undefined,\n          expectedArgument,\n          options\n        ),\n        `${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n          'received'\n        )} value must be a mock or spy function`,\n        (0, _jestMatcherUtils.printWithType)(\n          'Received',\n          received,\n          _jestMatcherUtils.printReceived\n        )\n      )\n    );\n  }\n};\n\nconst ensureMock = (received, matcherName, expectedArgument, options) => {\n  if (!isMock(received)) {\n    throw new Error(\n      (0, _jestMatcherUtils.matcherErrorMessage)(\n        (0, _jestMatcherUtils.matcherHint)(\n          matcherName,\n          undefined,\n          expectedArgument,\n          options\n        ),\n        `${(0, _jestMatcherUtils.RECEIVED_COLOR)(\n          'received'\n        )} value must be a mock function`,\n        (0, _jestMatcherUtils.printWithType)(\n          'Received',\n          received,\n          _jestMatcherUtils.printReceived\n        )\n      )\n    );\n  }\n};\n\nvar _default = spyMatchers;\nexports.default = _default;\n"]},"metadata":{},"sourceType":"script"}