{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectSpread = require(\"/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar escapeStringRegexp = require('escape-string-regexp');\n\nvar natives = [].concat(require('module').builtinModules, 'bootstrap_node', 'node').map(function (n) {\n  return new RegExp(\"(?:\\\\((?:node:)?\".concat(n, \"(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?\").concat(n, \"(?:\\\\.js)?:\\\\d+:\\\\d+$)\"));\n});\nnatives.push(/\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/, /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/, /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/);\n\nvar StackUtils = /*#__PURE__*/function () {\n  function StackUtils(opts) {\n    _classCallCheck(this, StackUtils);\n\n    opts = _objectSpread({\n      ignoredPackages: []\n    }, opts);\n\n    if ('internals' in opts === false) {\n      opts.internals = StackUtils.nodeInternals();\n    }\n\n    if ('cwd' in opts === false) {\n      opts.cwd = process.cwd();\n    }\n\n    this._cwd = opts.cwd.replace(/\\\\/g, '/');\n    this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));\n    this._wrapCallSite = opts.wrapCallSite || false;\n  }\n\n  _createClass(StackUtils, [{\n    key: \"clean\",\n    value: function clean(stack) {\n      var _this = this;\n\n      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      indent = ' '.repeat(indent);\n\n      if (!Array.isArray(stack)) {\n        stack = stack.split('\\n');\n      }\n\n      if (!/^\\s*at /.test(stack[0]) && /^\\s*at /.test(stack[1])) {\n        stack = stack.slice(1);\n      }\n\n      var outdent = false;\n      var lastNonAtLine = null;\n      var result = [];\n      stack.forEach(function (st) {\n        st = st.replace(/\\\\/g, '/');\n\n        if (_this._internals.some(function (internal) {\n          return internal.test(st);\n        })) {\n          return;\n        }\n\n        var isAtLine = /^\\s*at /.test(st);\n\n        if (outdent) {\n          st = st.trimEnd().replace(/^(\\s+)at /, '$1');\n        } else {\n          st = st.trim();\n\n          if (isAtLine) {\n            st = st.slice(3);\n          }\n        }\n\n        st = st.replace(\"\".concat(_this._cwd, \"/\"), '');\n\n        if (st) {\n          if (isAtLine) {\n            if (lastNonAtLine) {\n              result.push(lastNonAtLine);\n              lastNonAtLine = null;\n            }\n\n            result.push(st);\n          } else {\n            outdent = true;\n            lastNonAtLine = st;\n          }\n        }\n      });\n      return result.map(function (line) {\n        return \"\".concat(indent).concat(line, \"\\n\");\n      }).join('');\n    }\n  }, {\n    key: \"captureString\",\n    value: function captureString(limit) {\n      var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.captureString;\n\n      if (typeof limit === 'function') {\n        fn = limit;\n        limit = Infinity;\n      }\n\n      var stackTraceLimit = Error.stackTraceLimit;\n\n      if (limit) {\n        Error.stackTraceLimit = limit;\n      }\n\n      var obj = {};\n      Error.captureStackTrace(obj, fn);\n      var stack = obj.stack;\n      Error.stackTraceLimit = stackTraceLimit;\n      return this.clean(stack);\n    }\n  }, {\n    key: \"capture\",\n    value: function capture(limit) {\n      var _this2 = this;\n\n      var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.capture;\n\n      if (typeof limit === 'function') {\n        fn = limit;\n        limit = Infinity;\n      }\n\n      var prepareStackTrace = Error.prepareStackTrace,\n          stackTraceLimit = Error.stackTraceLimit;\n\n      Error.prepareStackTrace = function (obj, site) {\n        if (_this2._wrapCallSite) {\n          return site.map(_this2._wrapCallSite);\n        }\n\n        return site;\n      };\n\n      if (limit) {\n        Error.stackTraceLimit = limit;\n      }\n\n      var obj = {};\n      Error.captureStackTrace(obj, fn);\n      var stack = obj.stack;\n      Object.assign(Error, {\n        prepareStackTrace: prepareStackTrace,\n        stackTraceLimit: stackTraceLimit\n      });\n      return stack;\n    }\n  }, {\n    key: \"at\",\n    value: function at() {\n      var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.at;\n\n      var _this$capture = this.capture(1, fn),\n          _this$capture2 = _slicedToArray(_this$capture, 1),\n          site = _this$capture2[0];\n\n      if (!site) {\n        return {};\n      }\n\n      var res = {\n        line: site.getLineNumber(),\n        column: site.getColumnNumber()\n      };\n      setFile(res, site.getFileName(), this._cwd);\n\n      if (site.isConstructor()) {\n        res.constructor = true;\n      }\n\n      if (site.isEval()) {\n        res.evalOrigin = site.getEvalOrigin();\n      } // Node v10 stopped with the isNative() on callsites, apparently\n\n      /* istanbul ignore next */\n\n\n      if (site.isNative()) {\n        res.native = true;\n      }\n\n      var typename;\n\n      try {\n        typename = site.getTypeName();\n      } catch (_) {}\n\n      if (typename && typename !== 'Object' && typename !== '[object Object]') {\n        res.type = typename;\n      }\n\n      var fname = site.getFunctionName();\n\n      if (fname) {\n        res.function = fname;\n      }\n\n      var meth = site.getMethodName();\n\n      if (meth && fname !== meth) {\n        res.method = meth;\n      }\n\n      return res;\n    }\n  }, {\n    key: \"parseLine\",\n    value: function parseLine(line) {\n      var match = line && line.match(re);\n\n      if (!match) {\n        return null;\n      }\n\n      var ctor = match[1] === 'new';\n      var fname = match[2];\n      var evalOrigin = match[3];\n      var evalFile = match[4];\n      var evalLine = Number(match[5]);\n      var evalCol = Number(match[6]);\n      var file = match[7];\n      var lnum = match[8];\n      var col = match[9];\n      var native = match[10] === 'native';\n      var closeParen = match[11] === ')';\n      var method;\n      var res = {};\n\n      if (lnum) {\n        res.line = Number(lnum);\n      }\n\n      if (col) {\n        res.column = Number(col);\n      }\n\n      if (closeParen && file) {\n        // make sure parens are balanced\n        // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n        // that the fname should be += \" (asdf) [as foo]\" and the file\n        // should be just \"xyz.js\"\n        // walk backwards from the end to find the last unbalanced (\n        var closes = 0;\n\n        for (var i = file.length - 1; i > 0; i--) {\n          if (file.charAt(i) === ')') {\n            closes++;\n          } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n            closes--;\n\n            if (closes === -1 && file.charAt(i - 1) === ' ') {\n              var before = file.slice(0, i - 1);\n              var after = file.slice(i + 1);\n              file = after;\n              fname += \" (\".concat(before);\n              break;\n            }\n          }\n        }\n      }\n\n      if (fname) {\n        var methodMatch = fname.match(methodRe);\n\n        if (methodMatch) {\n          fname = methodMatch[1];\n          method = methodMatch[2];\n        }\n      }\n\n      setFile(res, file, this._cwd);\n\n      if (ctor) {\n        res.constructor = true;\n      }\n\n      if (evalOrigin) {\n        res.evalOrigin = evalOrigin;\n        res.evalLine = evalLine;\n        res.evalColumn = evalCol;\n        res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n      }\n\n      if (native) {\n        res.native = true;\n      }\n\n      if (fname) {\n        res.function = fname;\n      }\n\n      if (method && fname !== method) {\n        res.method = method;\n      }\n\n      return res;\n    }\n  }], [{\n    key: \"nodeInternals\",\n    value: function nodeInternals() {\n      return _toConsumableArray(natives);\n    }\n  }]);\n\n  return StackUtils;\n}();\n\nfunction setFile(result, filename, cwd) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n\n    if (filename.startsWith(\"\".concat(cwd, \"/\"))) {\n      filename = filename.slice(cwd.length + 1);\n    }\n\n    result.file = filename;\n  }\n}\n\nfunction ignoredPackagesRegExp(ignoredPackages) {\n  if (ignoredPackages.length === 0) {\n    return [];\n  }\n\n  var packages = ignoredPackages.map(function (mod) {\n    return escapeStringRegexp(mod);\n  });\n  return new RegExp(\"[/\\\\\\\\]node_modules[/\\\\\\\\](?:\".concat(packages.join('|'), \")[/\\\\\\\\][^:]+:\\\\d+:\\\\d+\"));\n}\n\nvar re = new RegExp('^' + // Sometimes we strip out the '    at' because it's noisy\n'(?:\\\\s*at )?' + // $1 = ctor if 'new'\n'(?:(new) )?' + // $2 = function name (can be literally anything)\n// May contain method at the end as [as xyz]\n'(?:(.*?) \\\\()?' + // (eval at <anonymous> (file.js:1:1),\n// $3 = eval origin\n// $4:$5:$6 are eval file/line/col, but not normally reported\n'(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' + // file:line:col\n// $7:$8:$9\n// $10 = 'native' if native\n'(?:(.+?):(\\\\d+):(\\\\d+)|(native))' + // maybe close the paren, then end\n// if $11 is ), then we only allow balanced parens in the filename\n// any imbalance is placed on the fname.  This is a heuristic, and\n// bound to be incorrect in some edge cases.  The bet is that\n// having weird characters in method names is more common than\n// having weird characters in filenames, which seems reasonable.\n'(\\\\)?)$');\nvar methodRe = /^(.*?) \\[as (.*?)\\]$/;\nmodule.exports = StackUtils;","map":{"version":3,"sources":["/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/ibm-cloud-sdk-core/node_modules/stack-utils/index.js"],"names":["escapeStringRegexp","require","natives","concat","builtinModules","map","n","RegExp","push","StackUtils","opts","ignoredPackages","internals","nodeInternals","cwd","process","_cwd","replace","_internals","ignoredPackagesRegExp","_wrapCallSite","wrapCallSite","stack","indent","repeat","Array","isArray","split","test","slice","outdent","lastNonAtLine","result","forEach","st","some","internal","isAtLine","trimEnd","trim","line","join","limit","fn","captureString","Infinity","stackTraceLimit","Error","obj","captureStackTrace","clean","capture","prepareStackTrace","site","Object","assign","at","res","getLineNumber","column","getColumnNumber","setFile","getFileName","isConstructor","constructor","isEval","evalOrigin","getEvalOrigin","isNative","native","typename","getTypeName","_","type","fname","getFunctionName","function","meth","getMethodName","method","match","re","ctor","evalFile","evalLine","Number","evalCol","file","lnum","col","closeParen","closes","i","length","charAt","before","after","methodMatch","methodRe","evalColumn","filename","startsWith","packages","mod","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst escapeStringRegexp = require('escape-string-regexp');\n\nconst natives = [].concat(\n  require('module').builtinModules,\n  'bootstrap_node',\n  'node',\n).map(n => new RegExp(`(?:\\\\((?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+\\\\)$|^\\\\s*at (?:node:)?${n}(?:\\\\.js)?:\\\\d+:\\\\d+$)`));\n\nnatives.push(\n  /\\((?:node:)?internal\\/[^:]+:\\d+:\\d+\\)$/,\n  /\\s*at (?:node:)?internal\\/[^:]+:\\d+:\\d+$/,\n  /\\/\\.node-spawn-wrap-\\w+-\\w+\\/node:\\d+:\\d+\\)?$/\n);\n\nclass StackUtils {\n  constructor (opts) {\n    opts = {\n      ignoredPackages: [],\n      ...opts\n    };\n\n    if ('internals' in opts === false) {\n      opts.internals = StackUtils.nodeInternals();\n    }\n\n    if ('cwd' in opts === false) {\n      opts.cwd = process.cwd()\n    }\n\n    this._cwd = opts.cwd.replace(/\\\\/g, '/');\n    this._internals = [].concat(\n      opts.internals,\n      ignoredPackagesRegExp(opts.ignoredPackages)\n    );\n\n    this._wrapCallSite = opts.wrapCallSite || false;\n  }\n\n  static nodeInternals () {\n    return [...natives];\n  }\n\n  clean (stack, indent = 0) {\n    indent = ' '.repeat(indent);\n\n    if (!Array.isArray(stack)) {\n      stack = stack.split('\\n');\n    }\n\n    if (!(/^\\s*at /.test(stack[0])) && (/^\\s*at /.test(stack[1]))) {\n      stack = stack.slice(1);\n    }\n\n    let outdent = false;\n    let lastNonAtLine = null;\n    const result = [];\n\n    stack.forEach(st => {\n      st = st.replace(/\\\\/g, '/');\n\n      if (this._internals.some(internal => internal.test(st))) {\n        return;\n      }\n\n      const isAtLine = /^\\s*at /.test(st);\n\n      if (outdent) {\n        st = st.trimEnd().replace(/^(\\s+)at /, '$1');\n      } else {\n        st = st.trim();\n        if (isAtLine) {\n          st = st.slice(3);\n        }\n      }\n\n      st = st.replace(`${this._cwd}/`, '');\n\n      if (st) {\n        if (isAtLine) {\n          if (lastNonAtLine) {\n            result.push(lastNonAtLine);\n            lastNonAtLine = null;\n          }\n\n          result.push(st);\n        } else {\n          outdent = true;\n          lastNonAtLine = st;\n        }\n      }\n    });\n\n    return result.map(line => `${indent}${line}\\n`).join('');\n  }\n\n  captureString (limit, fn = this.captureString) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const {stackTraceLimit} = Error;\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n\n    Error.captureStackTrace(obj, fn);\n    const {stack} = obj;\n    Error.stackTraceLimit = stackTraceLimit;\n\n    return this.clean(stack);\n  }\n\n  capture (limit, fn = this.capture) {\n    if (typeof limit === 'function') {\n      fn = limit;\n      limit = Infinity;\n    }\n\n    const {prepareStackTrace, stackTraceLimit} = Error;\n    Error.prepareStackTrace = (obj, site) => {\n      if (this._wrapCallSite) {\n        return site.map(this._wrapCallSite);\n      }\n\n      return site;\n    };\n\n    if (limit) {\n      Error.stackTraceLimit = limit;\n    }\n\n    const obj = {};\n    Error.captureStackTrace(obj, fn);\n    const { stack } = obj;\n    Object.assign(Error, {prepareStackTrace, stackTraceLimit});\n\n    return stack;\n  }\n\n  at (fn = this.at) {\n    const [site] = this.capture(1, fn);\n\n    if (!site) {\n      return {};\n    }\n\n    const res = {\n      line: site.getLineNumber(),\n      column: site.getColumnNumber()\n    };\n\n    setFile(res, site.getFileName(), this._cwd);\n\n    if (site.isConstructor()) {\n      res.constructor = true;\n    }\n\n    if (site.isEval()) {\n      res.evalOrigin = site.getEvalOrigin();\n    }\n\n    // Node v10 stopped with the isNative() on callsites, apparently\n    /* istanbul ignore next */\n    if (site.isNative()) {\n      res.native = true;\n    }\n\n    let typename;\n    try {\n      typename = site.getTypeName();\n    } catch (_) {\n    }\n\n    if (typename && typename !== 'Object' && typename !== '[object Object]') {\n      res.type = typename;\n    }\n\n    const fname = site.getFunctionName();\n    if (fname) {\n      res.function = fname;\n    }\n\n    const meth = site.getMethodName();\n    if (meth && fname !== meth) {\n      res.method = meth;\n    }\n\n    return res;\n  }\n\n  parseLine (line) {\n    const match = line && line.match(re);\n    if (!match) {\n      return null;\n    }\n\n    const ctor = match[1] === 'new';\n    let fname = match[2];\n    const evalOrigin = match[3];\n    const evalFile = match[4];\n    const evalLine = Number(match[5]);\n    const evalCol = Number(match[6]);\n    let file = match[7];\n    const lnum = match[8];\n    const col = match[9];\n    const native = match[10] === 'native';\n    const closeParen = match[11] === ')';\n    let method;\n\n    const res = {};\n\n    if (lnum) {\n      res.line = Number(lnum);\n    }\n\n    if (col) {\n      res.column = Number(col);\n    }\n\n    if (closeParen && file) {\n      // make sure parens are balanced\n      // if we have a file like \"asdf) [as foo] (xyz.js\", then odds are\n      // that the fname should be += \" (asdf) [as foo]\" and the file\n      // should be just \"xyz.js\"\n      // walk backwards from the end to find the last unbalanced (\n      let closes = 0;\n      for (let i = file.length - 1; i > 0; i--) {\n        if (file.charAt(i) === ')') {\n          closes++;\n        } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {\n          closes--;\n          if (closes === -1 && file.charAt(i - 1) === ' ') {\n            const before = file.slice(0, i - 1);\n            const after = file.slice(i + 1);\n            file = after;\n            fname += ` (${before}`;\n            break;\n          }\n        }\n      }\n    }\n\n    if (fname) {\n      const methodMatch = fname.match(methodRe);\n      if (methodMatch) {\n        fname = methodMatch[1];\n        method = methodMatch[2];\n      }\n    }\n\n    setFile(res, file, this._cwd);\n\n    if (ctor) {\n      res.constructor = true;\n    }\n\n    if (evalOrigin) {\n      res.evalOrigin = evalOrigin;\n      res.evalLine = evalLine;\n      res.evalColumn = evalCol;\n      res.evalFile = evalFile && evalFile.replace(/\\\\/g, '/');\n    }\n\n    if (native) {\n      res.native = true;\n    }\n\n    if (fname) {\n      res.function = fname;\n    }\n\n    if (method && fname !== method) {\n      res.method = method;\n    }\n\n    return res;\n  }\n}\n\nfunction setFile (result, filename, cwd) {\n  if (filename) {\n    filename = filename.replace(/\\\\/g, '/');\n    if (filename.startsWith(`${cwd}/`)) {\n      filename = filename.slice(cwd.length + 1);\n    }\n\n    result.file = filename;\n  }\n}\n\nfunction ignoredPackagesRegExp(ignoredPackages) {\n  if (ignoredPackages.length === 0) {\n    return [];\n  }\n\n  const packages = ignoredPackages.map(mod => escapeStringRegexp(mod));\n\n  return new RegExp(`[\\/\\\\\\\\]node_modules[\\/\\\\\\\\](?:${packages.join('|')})[\\/\\\\\\\\][^:]+:\\\\d+:\\\\d+`)\n}\n\nconst re = new RegExp(\n  '^' +\n    // Sometimes we strip out the '    at' because it's noisy\n  '(?:\\\\s*at )?' +\n    // $1 = ctor if 'new'\n  '(?:(new) )?' +\n    // $2 = function name (can be literally anything)\n    // May contain method at the end as [as xyz]\n  '(?:(.*?) \\\\()?' +\n    // (eval at <anonymous> (file.js:1:1),\n    // $3 = eval origin\n    // $4:$5:$6 are eval file/line/col, but not normally reported\n  '(?:eval at ([^ ]+) \\\\((.+?):(\\\\d+):(\\\\d+)\\\\), )?' +\n    // file:line:col\n    // $7:$8:$9\n    // $10 = 'native' if native\n  '(?:(.+?):(\\\\d+):(\\\\d+)|(native))' +\n    // maybe close the paren, then end\n    // if $11 is ), then we only allow balanced parens in the filename\n    // any imbalance is placed on the fname.  This is a heuristic, and\n    // bound to be incorrect in some edge cases.  The bet is that\n    // having weird characters in method names is more common than\n    // having weird characters in filenames, which seems reasonable.\n  '(\\\\)?)$'\n);\n\nconst methodRe = /^(.*?) \\[as (.*?)\\]$/;\n\nmodule.exports = StackUtils;\n"]},"metadata":{},"sourceType":"script"}