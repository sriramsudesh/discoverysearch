{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _codeFrame = require('@babel/code-frame');\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _micromatch = _interopRequireDefault(require('micromatch'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _prettyFormat = _interopRequireDefault(require('pretty-format'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== 'object' && typeof obj !== 'function') {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestReadFile = global[Symbol.for('jest-native-read-file')] || fs.readFileSync; // stack utils tries to create pretty stack by making paths relative.\n\nvar stackUtils = new _stackUtils.default({\n  cwd: 'something which does not exist'\n});\nvar nodeInternals = [];\n\ntry {\n  // https://github.com/tapjs/stack-utils/issues/54\n  nodeInternals = _stackUtils.default.nodeInternals().concat(/\\s*\\(node:/);\n} catch (_unused) {// `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\n\nvar PATH_NODE_MODULES = \"\".concat(path.sep, \"node_modules\").concat(path.sep);\nvar PATH_JEST_PACKAGES = \"\".concat(path.sep, \"jest\").concat(path.sep, \"packages\").concat(path.sep); // filter for noisy stack trace lines\n\nvar JASMINE_IGNORE = /^\\s+at(?:(?:.jasmine\\-)|\\s+jasmine\\.buildExpectationResult)/;\nvar JEST_INTERNALS_IGNORE = /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nvar ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nvar ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nvar ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nvar NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nvar TITLE_INDENT = '  ';\nvar MESSAGE_INDENT = '    ';\nvar STACK_INDENT = '      ';\nvar ANCESTRY_SEPARATOR = \" \\u203A \";\n\nvar TITLE_BULLET = _chalk.default.bold(\"\\u25CF \");\n\nvar STACK_TRACE_COLOR = _chalk.default.dim;\nvar STACK_PATH_REGEXP = /\\s*at.*\\(?(\\:\\d*\\:\\d*|native)\\)?/;\nvar EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nvar NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\n\nvar indentAllLines = function indentAllLines(lines, indent) {\n  return lines.replace(NOT_EMPTY_LINE_REGEXP, indent);\n};\n\nvar trim = function trim(string) {\n  return (string || '').trim();\n}; // Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\n\n\nvar trimPaths = function trimPaths(string) {\n  return string.match(STACK_PATH_REGEXP) ? trim(string) : string;\n};\n\nvar getRenderedCallsite = function getRenderedCallsite(fileContent, line, column) {\n  var renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, {\n    start: {\n      column: column,\n      line: line\n    }\n  }, {\n    highlightCode: true\n  });\n  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);\n  renderedCallsite = \"\\n\".concat(renderedCallsite, \"\\n\");\n  return renderedCallsite;\n};\n\nvar blankStringRegexp = /^\\s*$/;\n\nfunction checkForCommonEnvironmentErrors(error) {\n  if (error.includes('ReferenceError: document is not defined') || error.includes('ReferenceError: window is not defined') || error.includes('ReferenceError: navigator is not defined')) {\n    return warnAboutWrongTestEnvironment(error, 'jsdom');\n  } else if (error.includes('.unref is not a function')) {\n    return warnAboutWrongTestEnvironment(error, 'node');\n  }\n\n  return error;\n}\n\nfunction warnAboutWrongTestEnvironment(error, env) {\n  return _chalk.default.bold.red(\"The error below may be caused by using the wrong test environment, see \".concat(_chalk.default.dim.underline('https://jestjs.io/docs/en/configuration#testenvironment-string'), \".\\nConsider using the \\\"\").concat(env, \"\\\" test environment.\\n\\n\")) + error;\n} // ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\n\n\nvar formatExecError = function formatExecError(error, config, options, testPath, reuseMessage) {\n  if (!error || typeof error === 'number') {\n    error = new Error(\"Expected an Error, but \\\"\".concat(String(error), \"\\\" was thrown\"));\n    error.stack = '';\n  }\n\n  var message, stack;\n\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack = typeof error.stack === 'string' ? error.stack : \"thrown: \".concat((0, _prettyFormat.default)(error, {\n      maxDepth: 3\n    }));\n  }\n\n  var separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n\n  message = checkForCommonEnvironmentErrors(message);\n  message = indentAllLines(message, MESSAGE_INDENT);\n  stack = stack && !options.noStackTrace ? '\\n' + formatStackTrace(stack, config, options, testPath) : '';\n\n  if (typeof stack !== 'string' || blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {\n    // this can happen if an empty object is thrown.\n    message = \"thrown: \".concat((0, _prettyFormat.default)(error, {\n      maxDepth: 3\n    }));\n  }\n\n  var messageToUse;\n\n  if (reuseMessage) {\n    messageToUse = \" \".concat(message.trim());\n  } else {\n    messageToUse = \"\".concat(EXEC_ERROR_MESSAGE, \"\\n\\n\").concat(message);\n  }\n\n  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\\n';\n};\n\nexports.formatExecError = formatExecError;\n\nvar removeInternalStackEntries = function removeInternalStackEntries(lines, options) {\n  var pathCounter = 0;\n  return lines.filter(function (line) {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (nodeInternals.some(function (internal) {\n      return internal.test(line);\n    })) {\n      return false;\n    }\n\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nvar formatPaths = function formatPaths(config, relativeTestPath, line) {\n  // Extract the file path from the trace line.\n  var match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n\n  if (!match) {\n    return line;\n  }\n\n  var filePath = (0, _slash.default)(path.relative(config.rootDir, match[2])); // highlight paths from the current test file\n\n  if (config.testMatch && config.testMatch.length && (0, _micromatch.default)([filePath], config.testMatch).length > 0 || filePath === relativeTestPath) {\n    filePath = _chalk.default.reset.cyan(filePath);\n  }\n\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\n\nvar getStackTraceLines = function getStackTraceLines(stack) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    noCodeFrame: false,\n    noStackTrace: false\n  };\n  return removeInternalStackEntries(stack.split(/\\n/), options);\n};\n\nexports.getStackTraceLines = getStackTraceLines;\n\nvar getTopFrame = function getTopFrame(lines) {\n  var _iterator = _createForOfIteratorHelper(lines),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var line = _step.value;\n\n      if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n        continue;\n      }\n\n      var parsedFrame = stackUtils.parseLine(line.trim());\n\n      if (parsedFrame && parsedFrame.file) {\n        return parsedFrame;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return null;\n};\n\nexports.getTopFrame = getTopFrame;\n\nvar formatStackTrace = function formatStackTrace(stack, config, options, testPath) {\n  var lines = getStackTraceLines(stack, options);\n  var renderedCallsite = '';\n  var relativeTestPath = testPath ? (0, _slash.default)(path.relative(config.rootDir, testPath)) : null;\n\n  if (!options.noStackTrace && !options.noCodeFrame) {\n    var topFrame = getTopFrame(lines);\n\n    if (topFrame) {\n      var column = topFrame.column,\n          filename = topFrame.file,\n          line = topFrame.line;\n\n      if (line && filename && path.isAbsolute(filename)) {\n        var fileContent;\n\n        try {\n          // TODO: check & read HasteFS instead of reading the filesystem:\n          // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n          fileContent = jestReadFile(filename, 'utf8');\n          renderedCallsite = getRenderedCallsite(fileContent, line, column);\n        } catch (_unused2) {// the file does not exist or is inaccessible, we ignore\n        }\n      }\n    }\n  }\n\n  var stacktrace = lines.filter(Boolean).map(function (line) {\n    return STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line));\n  }).join('\\n');\n  return renderedCallsite ? \"\".concat(renderedCallsite, \"\\n\").concat(stacktrace) : \"\\n\".concat(stacktrace);\n};\n\nexports.formatStackTrace = formatStackTrace;\n\nvar formatResultsErrors = function formatResultsErrors(testResults, config, options, testPath) {\n  var failedResults = testResults.reduce(function (errors, result) {\n    result.failureMessages.map(checkForCommonEnvironmentErrors).forEach(function (content) {\n      return errors.push({\n        content: content,\n        result: result\n      });\n    });\n    return errors;\n  }, []);\n\n  if (!failedResults.length) {\n    return null;\n  }\n\n  return failedResults.map(function (_ref) {\n    var result = _ref.result,\n        content = _ref.content;\n\n    var _separateMessageFromS = separateMessageFromStack(content),\n        message = _separateMessageFromS.message,\n        stack = _separateMessageFromS.stack;\n\n    stack = options.noStackTrace ? '' : STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath)) + '\\n';\n    message = indentAllLines(message, MESSAGE_INDENT);\n    var title = _chalk.default.bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') + result.title) + '\\n';\n    return title + '\\n' + message + '\\n' + stack;\n  }).join('\\n');\n};\n\nexports.formatResultsErrors = formatResultsErrors;\nvar errorRegexp = /^Error:?\\s*$/;\n\nvar removeBlankErrorLine = function removeBlankErrorLine(str) {\n  return str.split('\\n') // Lines saying just `Error:` are useless\n  .filter(function (line) {\n    return !errorRegexp.test(line);\n  }).join('\\n').trimRight();\n}; // jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\n\n\nvar separateMessageFromStack = function separateMessageFromStack(content) {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n\n\n  var messageMatch = content.match(/^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/);\n\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n\n  var message = removeBlankErrorLine(messageMatch[1]);\n  var stack = removeBlankErrorLine(messageMatch[2]);\n  return {\n    message: message,\n    stack: stack\n  };\n};\n\nexports.separateMessageFromStack = separateMessageFromStack;","map":{"version":3,"sources":["/Users/sudesh/Documents/DEV2021/wacode/discovery-components-web/node_modules/ibm-cloud-sdk-core/node_modules/jest-message-util/build/index.js"],"names":["Object","defineProperty","exports","value","separateMessageFromStack","formatResultsErrors","formatStackTrace","getTopFrame","getStackTraceLines","formatExecError","path","_interopRequireWildcard","require","_codeFrame","_chalk","_interopRequireDefault","fs","_micromatch","_slash","_stackUtils","_prettyFormat","obj","__esModule","default","_getRequireWildcardCache","WeakMap","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","Symbol","global","jestReadFile","for","readFileSync","stackUtils","cwd","nodeInternals","concat","PATH_NODE_MODULES","sep","PATH_JEST_PACKAGES","JASMINE_IGNORE","JEST_INTERNALS_IGNORE","ANONYMOUS_FN_IGNORE","ANONYMOUS_PROMISE_IGNORE","ANONYMOUS_GENERATOR_IGNORE","NATIVE_NEXT_IGNORE","TITLE_INDENT","MESSAGE_INDENT","STACK_INDENT","ANCESTRY_SEPARATOR","TITLE_BULLET","bold","STACK_TRACE_COLOR","dim","STACK_PATH_REGEXP","EXEC_ERROR_MESSAGE","NOT_EMPTY_LINE_REGEXP","indentAllLines","lines","indent","replace","trim","string","trimPaths","match","getRenderedCallsite","fileContent","line","column","renderedCallsite","codeFrameColumns","start","highlightCode","blankStringRegexp","checkForCommonEnvironmentErrors","error","includes","warnAboutWrongTestEnvironment","env","red","underline","config","options","testPath","reuseMessage","Error","String","stack","message","maxDepth","separated","noStackTrace","test","messageToUse","removeInternalStackEntries","pathCounter","filter","some","internal","formatPaths","relativeTestPath","filePath","relative","rootDir","testMatch","length","reset","cyan","noCodeFrame","split","parsedFrame","parseLine","file","topFrame","filename","isAbsolute","stacktrace","Boolean","map","join","testResults","failedResults","reduce","errors","result","failureMessages","forEach","content","push","title","ancestorTitles","errorRegexp","removeBlankErrorLine","str","trimRight","messageMatch"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = void 0;\n\nvar path = _interopRequireWildcard(require('path'));\n\nvar _codeFrame = require('@babel/code-frame');\n\nvar _chalk = _interopRequireDefault(require('chalk'));\n\nvar fs = _interopRequireWildcard(require('graceful-fs'));\n\nvar _micromatch = _interopRequireDefault(require('micromatch'));\n\nvar _slash = _interopRequireDefault(require('slash'));\n\nvar _stackUtils = _interopRequireDefault(require('stack-utils'));\n\nvar _prettyFormat = _interopRequireDefault(require('pretty-format'));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {default: obj};\n}\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== 'function') return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {\n    return {default: obj};\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor =\n    Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor\n        ? Object.getOwnPropertyDescriptor(obj, key)\n        : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\n\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;\nvar jestReadFile =\n  global[Symbol.for('jest-native-read-file')] || fs.readFileSync;\n// stack utils tries to create pretty stack by making paths relative.\nconst stackUtils = new _stackUtils.default({\n  cwd: 'something which does not exist'\n});\nlet nodeInternals = [];\n\ntry {\n  // https://github.com/tapjs/stack-utils/issues/54\n  nodeInternals = _stackUtils.default.nodeInternals().concat(/\\s*\\(node:/);\n} catch {\n  // `StackUtils.nodeInternals()` fails in browsers. We don't need to remove\n  // node internals in the browser though, so no issue.\n}\n\nconst PATH_NODE_MODULES = `${path.sep}node_modules${path.sep}`;\nconst PATH_JEST_PACKAGES = `${path.sep}jest${path.sep}packages${path.sep}`; // filter for noisy stack trace lines\n\nconst JASMINE_IGNORE = /^\\s+at(?:(?:.jasmine\\-)|\\s+jasmine\\.buildExpectationResult)/;\nconst JEST_INTERNALS_IGNORE = /^\\s+at.*?jest(-.*?)?(\\/|\\\\)(build|node_modules|packages)(\\/|\\\\)/;\nconst ANONYMOUS_FN_IGNORE = /^\\s+at <anonymous>.*$/;\nconst ANONYMOUS_PROMISE_IGNORE = /^\\s+at (new )?Promise \\(<anonymous>\\).*$/;\nconst ANONYMOUS_GENERATOR_IGNORE = /^\\s+at Generator.next \\(<anonymous>\\).*$/;\nconst NATIVE_NEXT_IGNORE = /^\\s+at next \\(native\\).*$/;\nconst TITLE_INDENT = '  ';\nconst MESSAGE_INDENT = '    ';\nconst STACK_INDENT = '      ';\nconst ANCESTRY_SEPARATOR = ' \\u203A ';\n\nconst TITLE_BULLET = _chalk.default.bold('\\u25cf ');\n\nconst STACK_TRACE_COLOR = _chalk.default.dim;\nconst STACK_PATH_REGEXP = /\\s*at.*\\(?(\\:\\d*\\:\\d*|native)\\)?/;\nconst EXEC_ERROR_MESSAGE = 'Test suite failed to run';\nconst NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;\n\nconst indentAllLines = (lines, indent) =>\n  lines.replace(NOT_EMPTY_LINE_REGEXP, indent);\n\nconst trim = string => (string || '').trim(); // Some errors contain not only line numbers in stack traces\n// e.g. SyntaxErrors can contain snippets of code, and we don't\n// want to trim those, because they may have pointers to the column/character\n// which will get misaligned.\n\nconst trimPaths = string =>\n  string.match(STACK_PATH_REGEXP) ? trim(string) : string;\n\nconst getRenderedCallsite = (fileContent, line, column) => {\n  let renderedCallsite = (0, _codeFrame.codeFrameColumns)(\n    fileContent,\n    {\n      start: {\n        column,\n        line\n      }\n    },\n    {\n      highlightCode: true\n    }\n  );\n  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);\n  renderedCallsite = `\\n${renderedCallsite}\\n`;\n  return renderedCallsite;\n};\n\nconst blankStringRegexp = /^\\s*$/;\n\nfunction checkForCommonEnvironmentErrors(error) {\n  if (\n    error.includes('ReferenceError: document is not defined') ||\n    error.includes('ReferenceError: window is not defined') ||\n    error.includes('ReferenceError: navigator is not defined')\n  ) {\n    return warnAboutWrongTestEnvironment(error, 'jsdom');\n  } else if (error.includes('.unref is not a function')) {\n    return warnAboutWrongTestEnvironment(error, 'node');\n  }\n\n  return error;\n}\n\nfunction warnAboutWrongTestEnvironment(error, env) {\n  return (\n    _chalk.default.bold.red(\n      `The error below may be caused by using the wrong test environment, see ${_chalk.default.dim.underline(\n        'https://jestjs.io/docs/en/configuration#testenvironment-string'\n      )}.\\nConsider using the \"${env}\" test environment.\\n\\n`\n    ) + error\n  );\n} // ExecError is an error thrown outside of the test suite (not inside an `it` or\n// `before/after each` hooks). If it's thrown, none of the tests in the file\n// are executed.\n\nconst formatExecError = (error, config, options, testPath, reuseMessage) => {\n  if (!error || typeof error === 'number') {\n    error = new Error(`Expected an Error, but \"${String(error)}\" was thrown`);\n    error.stack = '';\n  }\n\n  let message, stack;\n\n  if (typeof error === 'string' || !error) {\n    error || (error = 'EMPTY ERROR');\n    message = '';\n    stack = error;\n  } else {\n    message = error.message;\n    stack =\n      typeof error.stack === 'string'\n        ? error.stack\n        : `thrown: ${(0, _prettyFormat.default)(error, {\n            maxDepth: 3\n          })}`;\n  }\n\n  const separated = separateMessageFromStack(stack || '');\n  stack = separated.stack;\n\n  if (separated.message.includes(trim(message))) {\n    // Often stack trace already contains the duplicate of the message\n    message = separated.message;\n  }\n\n  message = checkForCommonEnvironmentErrors(message);\n  message = indentAllLines(message, MESSAGE_INDENT);\n  stack =\n    stack && !options.noStackTrace\n      ? '\\n' + formatStackTrace(stack, config, options, testPath)\n      : '';\n\n  if (\n    typeof stack !== 'string' ||\n    (blankStringRegexp.test(message) && blankStringRegexp.test(stack))\n  ) {\n    // this can happen if an empty object is thrown.\n    message = `thrown: ${(0, _prettyFormat.default)(error, {\n      maxDepth: 3\n    })}`;\n  }\n\n  let messageToUse;\n\n  if (reuseMessage) {\n    messageToUse = ` ${message.trim()}`;\n  } else {\n    messageToUse = `${EXEC_ERROR_MESSAGE}\\n\\n${message}`;\n  }\n\n  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\\n';\n};\n\nexports.formatExecError = formatExecError;\n\nconst removeInternalStackEntries = (lines, options) => {\n  let pathCounter = 0;\n  return lines.filter(line => {\n    if (ANONYMOUS_FN_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (NATIVE_NEXT_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (nodeInternals.some(internal => internal.test(line))) {\n      return false;\n    }\n\n    if (!STACK_PATH_REGEXP.test(line)) {\n      return true;\n    }\n\n    if (JASMINE_IGNORE.test(line)) {\n      return false;\n    }\n\n    if (++pathCounter === 1) {\n      return true; // always keep the first line even if it's from Jest\n    }\n\n    if (options.noStackTrace) {\n      return false;\n    }\n\n    if (JEST_INTERNALS_IGNORE.test(line)) {\n      return false;\n    }\n\n    return true;\n  });\n};\n\nconst formatPaths = (config, relativeTestPath, line) => {\n  // Extract the file path from the trace line.\n  const match = line.match(/(^\\s*at .*?\\(?)([^()]+)(:[0-9]+:[0-9]+\\)?.*$)/);\n\n  if (!match) {\n    return line;\n  }\n\n  let filePath = (0, _slash.default)(path.relative(config.rootDir, match[2])); // highlight paths from the current test file\n\n  if (\n    (config.testMatch &&\n      config.testMatch.length &&\n      (0, _micromatch.default)([filePath], config.testMatch).length > 0) ||\n    filePath === relativeTestPath\n  ) {\n    filePath = _chalk.default.reset.cyan(filePath);\n  }\n\n  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);\n};\n\nconst getStackTraceLines = (\n  stack,\n  options = {\n    noCodeFrame: false,\n    noStackTrace: false\n  }\n) => removeInternalStackEntries(stack.split(/\\n/), options);\n\nexports.getStackTraceLines = getStackTraceLines;\n\nconst getTopFrame = lines => {\n  for (const line of lines) {\n    if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {\n      continue;\n    }\n\n    const parsedFrame = stackUtils.parseLine(line.trim());\n\n    if (parsedFrame && parsedFrame.file) {\n      return parsedFrame;\n    }\n  }\n\n  return null;\n};\n\nexports.getTopFrame = getTopFrame;\n\nconst formatStackTrace = (stack, config, options, testPath) => {\n  const lines = getStackTraceLines(stack, options);\n  let renderedCallsite = '';\n  const relativeTestPath = testPath\n    ? (0, _slash.default)(path.relative(config.rootDir, testPath))\n    : null;\n\n  if (!options.noStackTrace && !options.noCodeFrame) {\n    const topFrame = getTopFrame(lines);\n\n    if (topFrame) {\n      const {column, file: filename, line} = topFrame;\n\n      if (line && filename && path.isAbsolute(filename)) {\n        let fileContent;\n\n        try {\n          // TODO: check & read HasteFS instead of reading the filesystem:\n          // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696\n          fileContent = jestReadFile(filename, 'utf8');\n          renderedCallsite = getRenderedCallsite(fileContent, line, column);\n        } catch {\n          // the file does not exist or is inaccessible, we ignore\n        }\n      }\n    }\n  }\n\n  const stacktrace = lines\n    .filter(Boolean)\n    .map(\n      line =>\n        STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line))\n    )\n    .join('\\n');\n  return renderedCallsite\n    ? `${renderedCallsite}\\n${stacktrace}`\n    : `\\n${stacktrace}`;\n};\n\nexports.formatStackTrace = formatStackTrace;\n\nconst formatResultsErrors = (testResults, config, options, testPath) => {\n  const failedResults = testResults.reduce((errors, result) => {\n    result.failureMessages\n      .map(checkForCommonEnvironmentErrors)\n      .forEach(content =>\n        errors.push({\n          content,\n          result\n        })\n      );\n    return errors;\n  }, []);\n\n  if (!failedResults.length) {\n    return null;\n  }\n\n  return failedResults\n    .map(({result, content}) => {\n      let {message, stack} = separateMessageFromStack(content);\n      stack = options.noStackTrace\n        ? ''\n        : STACK_TRACE_COLOR(\n            formatStackTrace(stack, config, options, testPath)\n          ) + '\\n';\n      message = indentAllLines(message, MESSAGE_INDENT);\n      const title =\n        _chalk.default.bold.red(\n          TITLE_INDENT +\n            TITLE_BULLET +\n            result.ancestorTitles.join(ANCESTRY_SEPARATOR) +\n            (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') +\n            result.title\n        ) + '\\n';\n      return title + '\\n' + message + '\\n' + stack;\n    })\n    .join('\\n');\n};\n\nexports.formatResultsErrors = formatResultsErrors;\nconst errorRegexp = /^Error:?\\s*$/;\n\nconst removeBlankErrorLine = str =>\n  str\n    .split('\\n') // Lines saying just `Error:` are useless\n    .filter(line => !errorRegexp.test(line))\n    .join('\\n')\n    .trimRight(); // jasmine and worker farm sometimes don't give us access to the actual\n// Error object, so we have to regexp out the message from the stack string\n// to format it.\n\nconst separateMessageFromStack = content => {\n  if (!content) {\n    return {\n      message: '',\n      stack: ''\n    };\n  } // All lines up to what looks like a stack -- or if nothing looks like a stack\n  // (maybe it's a code frame instead), just the first non-empty line.\n  // If the error is a plain \"Error:\" instead of a SyntaxError or TypeError we\n  // remove the prefix from the message because it is generally not useful.\n\n  const messageMatch = content.match(\n    /^(?:Error: )?([\\s\\S]*?(?=\\n\\s*at\\s.*:\\d*:\\d*)|\\s*.*)([\\s\\S]*)$/\n  );\n\n  if (!messageMatch) {\n    // For typescript\n    throw new Error('If you hit this error, the regex above is buggy.');\n  }\n\n  const message = removeBlankErrorLine(messageMatch[1]);\n  const stack = removeBlankErrorLine(messageMatch[2]);\n  return {\n    message,\n    stack\n  };\n};\n\nexports.separateMessageFromStack = separateMessageFromStack;\n"]},"metadata":{},"sourceType":"script"}